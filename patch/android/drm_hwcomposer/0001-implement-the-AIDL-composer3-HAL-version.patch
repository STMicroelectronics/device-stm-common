From ca22890db4c61ea12481f9d3c2c24c0f81fff647 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Julien=20Qu=C3=A9r=C3=A9?= <jquere@witekio.com>
Date: Wed, 12 Jul 2023 14:31:23 +0200
Subject: [PATCH 1/2] implement the AIDL composer3 HAL version

Change-Id: I2dbe8bbb2ba8122aa7451b2da620f3b98afb84c5
---
 Android.bp                      |    1 +
 drm/DrmAtomicStateManager.cpp   |   10 +
 drm/DrmAtomicStateManager.h     |    3 +
 drm/DrmConnector.cpp            |    5 +
 drm/DrmConnector.h              |    5 +
 drm/DrmCrtc.cpp                 |    6 +
 drm/DrmCrtc.h                   |    5 +
 hwc2_device/DrmHwcTwo.cpp       |   33 +
 hwc2_device/DrmHwcTwo.h         |    9 +
 hwc2_device/Hwc3Types.h         |   32 +
 hwc2_device/HwcDisplay.cpp      |  123 +++
 hwc2_device/HwcDisplay.h        |   25 +
 hwc2_device/HwcLayer.cpp        |   40 +-
 hwc2_device/HwcLayer.h          |   17 +
 hwc2_device/hwc2_device.cpp     |   30 +
 hwc3/Android.bp                 |   60 ++
 hwc3/Composer.cpp               |   98 ++
 hwc3/Composer.h                 |   50 ++
 hwc3/ComposerClient.cpp         |  578 ++++++++++++
 hwc3/ComposerClient.h           |  144 +++
 hwc3/ComposerCommandEngine.cpp  |  453 ++++++++++
 hwc3/ComposerCommandEngine.h    |  119 +++
 hwc3/NOTICE                     |  190 ++++
 hwc3/Util.h                     |   93 ++
 hwc3/impl/HalImpl.cpp           | 1479 +++++++++++++++++++++++++++++++
 hwc3/impl/HalImpl.h             |  167 ++++
 hwc3/impl/ResourceManager.cpp   |  252 ++++++
 hwc3/impl/ResourceManager.h     |   79 ++
 hwc3/impl/TranslateHwcAidl.h    |  180 ++++
 hwc3/include/IComposerHal.h     |  224 +++++
 hwc3/include/IResourceManager.h |   75 ++
 hwc3/service.cpp                |   66 ++
 32 files changed, 4650 insertions(+), 1 deletion(-)
 create mode 100644 hwc2_device/Hwc3Types.h
 create mode 100644 hwc3/Android.bp
 create mode 100644 hwc3/Composer.cpp
 create mode 100644 hwc3/Composer.h
 create mode 100644 hwc3/ComposerClient.cpp
 create mode 100644 hwc3/ComposerClient.h
 create mode 100644 hwc3/ComposerCommandEngine.cpp
 create mode 100644 hwc3/ComposerCommandEngine.h
 create mode 100644 hwc3/NOTICE
 create mode 100644 hwc3/Util.h
 create mode 100644 hwc3/impl/HalImpl.cpp
 create mode 100644 hwc3/impl/HalImpl.h
 create mode 100644 hwc3/impl/ResourceManager.cpp
 create mode 100644 hwc3/impl/ResourceManager.h
 create mode 100644 hwc3/impl/TranslateHwcAidl.h
 create mode 100644 hwc3/include/IComposerHal.h
 create mode 100644 hwc3/include/IResourceManager.h
 create mode 100644 hwc3/service.cpp

diff --git a/Android.bp b/Android.bp
index 62c7e0c..a78eec3 100644
--- a/Android.bp
+++ b/Android.bp
@@ -42,6 +42,7 @@ cc_defaults {
     name: "hwcomposer.drm_defaults",
 
     shared_libs: [
+        "android.hardware.graphics.composer3-V1-ndk",
         "libcutils",
         "libdrm",
         "libhardware",
diff --git a/drm/DrmAtomicStateManager.cpp b/drm/DrmAtomicStateManager.cpp
index 4ff16e2..833e77f 100644
--- a/drm/DrmAtomicStateManager.cpp
+++ b/drm/DrmAtomicStateManager.cpp
@@ -121,6 +121,16 @@ auto DrmAtomicStateManager::CommitFrame(AtomicCommitArgs &args) -> int {
       return -EINVAL;
   }
 
+  if (args.expected_present_time && crtc->GetExpectedPresentTimeProperty()) {
+    new_frame_state.expected_present_time = *args.expected_present_time;
+
+    if (!crtc->GetExpectedPresentTimeProperty()
+                    .AtomicSet(*pset, new_frame_state.expected_present_time)) {
+      ALOGE("Failed to set expected present time property");
+      return -EINVAL;
+    }
+  }
+
   auto unused_planes = new_frame_state.used_planes;
 
   if (args.composition) {
diff --git a/drm/DrmAtomicStateManager.h b/drm/DrmAtomicStateManager.h
index 6e32a37..733b13b 100644
--- a/drm/DrmAtomicStateManager.h
+++ b/drm/DrmAtomicStateManager.h
@@ -34,6 +34,7 @@ struct AtomicCommitArgs {
   bool test_only = false;
   std::optional<DrmMode> display_mode;
   std::optional<bool> active;
+  std::optional<uint64_t> expected_present_time;
   std::shared_ptr<DrmKmsPlan> composition;
   std::shared_ptr<drm_color_ctm> color_matrix;
 
@@ -82,6 +83,8 @@ class DrmAtomicStateManager {
 
     /* To avoid setting the inactive state twice, which will fail the commit */
     bool crtc_active_state{};
+
+    uint64_t expected_present_time{};
   } active_frame_state_;
 
   auto NewFrameState() -> KmsState {
diff --git a/drm/DrmConnector.cpp b/drm/DrmConnector.cpp
index f625563..5c4ccf0 100644
--- a/drm/DrmConnector.cpp
+++ b/drm/DrmConnector.cpp
@@ -89,6 +89,11 @@ auto DrmConnector::CreateInstance(DrmDevice &dev, uint32_t connector_id,
     return {};
   }
 
+  if (!GetOptionalConnectorProperty(dev, *c, "panel orientation",
+                                    &c->orientation_)) {
+    ALOGV("Missing optional panel orientation property");
+  }
+
   return c;
 }
 
diff --git a/drm/DrmConnector.h b/drm/DrmConnector.h
index f21f598..0153c34 100644
--- a/drm/DrmConnector.h
+++ b/drm/DrmConnector.h
@@ -94,6 +94,10 @@ class DrmConnector : public PipelineBindable<DrmConnector> {
     return edid_property_;
   }
 
+  auto &GetOrientation() const {
+    return orientation_;
+  }
+
   auto IsConnected() const {
     return connector_->connection == DRM_MODE_CONNECTED;
   }
@@ -125,5 +129,6 @@ class DrmConnector : public PipelineBindable<DrmConnector> {
   DrmProperty writeback_pixel_formats_;
   DrmProperty writeback_fb_id_;
   DrmProperty writeback_out_fence_;
+  DrmProperty orientation_;
 };
 }  // namespace android
diff --git a/drm/DrmCrtc.cpp b/drm/DrmCrtc.cpp
index 948a9ac..ce45b83 100644
--- a/drm/DrmCrtc.cpp
+++ b/drm/DrmCrtc.cpp
@@ -61,6 +61,12 @@ auto DrmCrtc::CreateInstance(DrmDevice &dev, uint32_t crtc_id, uint32_t index)
     return {};
   }
 
+  ret = GetCrtcProperty(dev, *c, "expected_present_time", &c->expected_present_time_property_);
+  if (ret != 0) {
+    ALOGE("Failed to get expected_present_time property");
+    return {};
+  }
+
   ret = GetCrtcProperty(dev, *c, "CTM", &c->ctm_property_);
   if (ret != 0) {
     ALOGV("Missing optional CTM property");
diff --git a/drm/DrmCrtc.h b/drm/DrmCrtc.h
index 96443cd..c21a8da 100644
--- a/drm/DrmCrtc.h
+++ b/drm/DrmCrtc.h
@@ -62,6 +62,10 @@ class DrmCrtc : public PipelineBindable<DrmCrtc> {
     return ctm_property_;
   }
 
+  auto &GetExpectedPresentTimeProperty() const {
+    return expected_present_time_property_;
+  }
+
  private:
   DrmCrtc(DrmModeCrtcUnique crtc, uint32_t index)
       : crtc_(std::move(crtc)), index_in_res_array_(index){};
@@ -75,5 +79,6 @@ class DrmCrtc : public PipelineBindable<DrmCrtc> {
   DrmProperty active_property_;
   DrmProperty mode_property_;
   DrmProperty out_fence_ptr_property_;
+  DrmProperty expected_present_time_property_;
 };
 }  // namespace android
diff --git a/hwc2_device/DrmHwcTwo.cpp b/hwc2_device/DrmHwcTwo.cpp
index 64755c3..6151b34 100644
--- a/hwc2_device/DrmHwcTwo.cpp
+++ b/hwc2_device/DrmHwcTwo.cpp
@@ -20,9 +20,13 @@
 
 #include <cinttypes>
 
+#include <aidl/android/hardware/graphics/composer3/BnComposerClient.h>
+
 #include "backend/Backend.h"
 #include "utils/log.h"
 
+using aidl::android::hardware::graphics::composer3::IComposerCallback;
+
 namespace android {
 
 DrmHwcTwo::DrmHwcTwo() : resource_manager_(this){};
@@ -124,6 +128,10 @@ bool DrmHwcTwo::UnbindDisplay(DrmDisplayPipeline *pipeline) {
   return true;
 }
 
+void DrmHwcTwo::GetCapabilities(uint32_t* outCount, int32_t* /* outCapabilities */) {
+    *outCount = 0;
+}
+
 HWC2::Error DrmHwcTwo::CreateVirtualDisplay(uint32_t /*width*/,
                                             uint32_t /*height*/,
                                             int32_t * /*format*/,
@@ -250,4 +258,29 @@ void DrmHwcTwo::SendVsyncPeriodTimingChangedEventToClient(
 #endif
 }
 
+HWC2::Error DrmHwcTwo::RegisterHwc3Callback(
+    [[maybe_unused]] int32_t descriptor,
+    [[maybe_unused]] hwc2_callback_data_t data,
+    [[maybe_unused]] hwc2_function_pointer_t function) {
+#if __ANDROID_API__ > 32
+  switch (descriptor) {
+    case IComposerCallback::TRANSACTION_onVsyncIdle:
+      vsync_idle_callback_ = std::make_pair(HWC2_PFN_VSYNC_IDLE(function), data);
+      break;
+  }
+
+#endif
+  return HWC2::Error::None;
+}
+
+void DrmHwcTwo::SendVsyncIdleEventToClient(
+    [[maybe_unused]] hwc2_display_t displayid) const {
+#if __ANDROID_API__ > 32
+  auto cb = vsync_idle_callback_;
+  if (cb.first != nullptr && cb.second != nullptr) {
+    cb.first(cb.second, displayid);
+  }
+#endif
+}
+
 }  // namespace android
diff --git a/hwc2_device/DrmHwcTwo.h b/hwc2_device/DrmHwcTwo.h
index 81c5155..f22cad0 100644
--- a/hwc2_device/DrmHwcTwo.h
+++ b/hwc2_device/DrmHwcTwo.h
@@ -34,10 +34,16 @@ class DrmHwcTwo : public PipelineToFrontendBindingInterface {
   std::pair<HWC2_PFN_VSYNC_2_4, hwc2_callback_data_t> vsync_2_4_callback_{};
   std::pair<HWC2_PFN_VSYNC_PERIOD_TIMING_CHANGED, hwc2_callback_data_t>
       period_timing_changed_callback_{};
+#endif
+#if __ANDROID_API__ > 32
+  using HWC2_PFN_VSYNC_IDLE = void (*)(hwc2_callback_data_t data, hwc2_display_t hwcDisplay);
+
+  std::pair<HWC2_PFN_VSYNC_IDLE, hwc2_callback_data_t> vsync_idle_callback_{};
 #endif
   std::pair<HWC2_PFN_REFRESH, hwc2_callback_data_t> refresh_callback_{};
 
   // Device functions
+  void GetCapabilities(uint32_t* outCount, int32_t* outCapabilities);
   HWC2::Error CreateVirtualDisplay(uint32_t width, uint32_t height,
                                    int32_t *format, hwc2_display_t *display);
   HWC2::Error DestroyVirtualDisplay(hwc2_display_t display);
@@ -45,6 +51,8 @@ class DrmHwcTwo : public PipelineToFrontendBindingInterface {
   uint32_t GetMaxVirtualDisplayCount();
   HWC2::Error RegisterCallback(int32_t descriptor, hwc2_callback_data_t data,
                                hwc2_function_pointer_t function);
+  HWC2::Error RegisterHwc3Callback(int32_t descriptor, hwc2_callback_data_t data,
+                                   hwc2_function_pointer_t function);
 
   auto GetDisplay(hwc2_display_t display_handle) {
     return displays_.count(display_handle) != 0
@@ -69,6 +77,7 @@ class DrmHwcTwo : public PipelineToFrontendBindingInterface {
                               uint32_t vsync_period) const;
   void SendVsyncPeriodTimingChangedEventToClient(hwc2_display_t displayid,
                                                  int64_t timestamp) const;
+  void SendVsyncIdleEventToClient(hwc2_display_t displayid) const;
 
  private:
   void SendHotplugEventToClient(hwc2_display_t displayid, bool connected) const;
diff --git a/hwc2_device/Hwc3Types.h b/hwc2_device/Hwc3Types.h
new file mode 100644
index 0000000..b4a24b3
--- /dev/null
+++ b/hwc2_device/Hwc3Types.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef ANDROID_HWC3_DEVICE_HWC3_TYPES_H_
+#define ANDROID_HWC3_DEVICE_HWC3_TYPES_H_
+
+enum class HwcMountOrientation {
+    ROT_0 = 0,
+    ROT_90,
+    ROT_180,
+    ROT_270,
+};
+
+enum class HwcDimmingStage {
+    DIMMING_NONE = 0,
+    DIMMING_LINEAR,
+    DIMMING_OETF,
+};
+
+#endif
diff --git a/hwc2_device/HwcDisplay.cpp b/hwc2_device/HwcDisplay.cpp
index efd8c14..b70e7d9 100644
--- a/hwc2_device/HwcDisplay.cpp
+++ b/hwc2_device/HwcDisplay.cpp
@@ -136,6 +136,7 @@ void HwcDisplay::Deinit() {
 
 HWC2::Error HwcDisplay::Init() {
   ChosePreferredConfig();
+  UpdateMountOrientation();
 
   auto vsw_callbacks = (VSyncWorkerCallbacks){
       .out_event =
@@ -202,6 +203,43 @@ HWC2::Error HwcDisplay::ChosePreferredConfig() {
   return SetActiveConfig(configs_.preferred_config_id);
 }
 
+void HwcDisplay::UpdateMountOrientation() {
+  if (IsInHeadlessMode())
+    return;
+
+  const std::vector<
+            std::pair<HwcMountOrientation, const char *>
+        > orientationEnums = {
+    { HwcMountOrientation::ROT_0, "Normal" },
+    { HwcMountOrientation::ROT_90, "Left Side Up" },
+    { HwcMountOrientation::ROT_180, "Upside Down" },
+    { HwcMountOrientation::ROT_270, "Right Side Up" },
+  };
+
+  mount_orientation_ = HwcMountOrientation::ROT_0;
+  auto &orientation = GetPipe().connector->Get()->GetOrientation();
+  if (!orientation)
+    return;
+
+  auto drmOrientation = orientation.GetValue();
+  if (!drmOrientation) {
+    ALOGW("%s failed to get drm prop value", __func__);
+    return;
+  }
+
+  int err = 0;
+  for (auto &e : orientationEnums) {
+    uint64_t enumValue;
+    std::tie(enumValue, err) = orientation.GetEnumValueWithName(e.second);
+    if (!err && enumValue == *drmOrientation) {
+        mount_orientation_ = e.first;
+        return;
+    }
+  }
+
+  ALOGW("%s ignore unrecognized orientation %lu", __func__, *drmOrientation);
+}
+
 HWC2::Error HwcDisplay::AcceptDisplayChanges() {
   for (std::pair<const hwc2_layer_t, HwcLayer> &l : layers_)
     l.second.AcceptTypeChange();
@@ -537,6 +575,10 @@ HWC2::Error HwcDisplay::CreateComposition(AtomicCommitArgs &a_args) {
 
   a_args.composition = current_plan_;
 
+  if (expected_present_time_ != 0) {
+    a_args.expected_present_time = expected_present_time_;
+  }
+
   auto ret = GetPipe().atomic_state_manager->ExecuteAtomicCommit(a_args);
 
   if (ret) {
@@ -573,6 +615,8 @@ HWC2::Error HwcDisplay::PresentDisplay(int32_t *out_present_fence) {
   AtomicCommitArgs a_args{};
   ret = CreateComposition(a_args);
 
+  expected_present_time_.reset();
+
   if (ret != HWC2::Error::None)
     ++total_stats_.failed_kms_present_;
 
@@ -792,6 +836,9 @@ HWC2::Error HwcDisplay::ValidateDisplay(uint32_t *num_types,
    * this state to provide the CLIENT with the release fences for such buffers.
    */
   for (auto &l : layers_) {
+    if (l.second.GetSfType() > HWC2::Composition::Sideband)
+      return HWC2::Error::Unsupported;
+
     l.second.SetPriorBufferScanOutFlag(l.second.GetValidatedType() !=
                                        HWC2::Composition::Client);
   }
@@ -822,6 +869,66 @@ HWC2::Error HwcDisplay::GetDisplayVsyncPeriod(
                              (int32_t *)(outVsyncPeriod));
 }
 
+#if __ANDROID_API__ > 32
+HWC2::Error HwcDisplay::GetMountOrientation(HwcMountOrientation *orientation) {
+  if (!orientation)
+    return HWC2::Error::BadParameter;
+
+  *orientation = mount_orientation_;
+
+  return HWC2::Error::None;
+}
+
+HWC2::Error HwcDisplay::GetRCDLayerSupport(bool *supported) const {
+  *supported = false;
+  return HWC2::Error::None;
+}
+
+HWC2::Error HwcDisplay::SetExpectedPresentTime(uint64_t presentTime) {
+  if (expected_present_time_)
+    ALOGW("HalImpl: set expected present time multiple times in one frame");
+
+  expected_present_time_ = presentTime;
+
+  return HWC2::Error::None;
+}
+
+HWC2::Error HwcDisplay::GetDisplayIdleTimerSupport(bool *supported) {
+  *supported = false;
+  return HWC2::Error::None;
+}
+
+HWC2::Error HwcDisplay::SetBootDisplayConfig(int32_t configId) {
+  if (configs_.hwc_configs.count(configId) == 0)
+    return HWC2::Error::BadConfig;
+
+  return HWC2::Error::Unsupported;
+}
+
+HWC2::Error HwcDisplay::ClearBootDisplayConfig() {
+  return HWC2::Error::Unsupported;
+}
+
+HWC2::Error HwcDisplay::GetPreferredBootDisplayConfig(int32_t * /* outConfigId */) {
+  // *outConfigId = static_cast<int32_t>(configs_.preferred_config_id);
+  // return HWC2::Error::None;
+  return HWC2::Error::Unsupported;
+}
+
+HWC2::Error HwcDisplay::GetClientTargetProperty(
+    hwc_client_target_property_t *outClientTargetProperty,
+    HwcDimmingStage *outDimmingStage) {
+  outClientTargetProperty->pixelFormat = HAL_PIXEL_FORMAT_RGBA_8888;
+  outClientTargetProperty->dataspace = HAL_DATASPACE_UNKNOWN;
+
+  if (outDimmingStage != nullptr)
+    *outDimmingStage = HwcDimmingStage::DIMMING_NONE;
+
+  return HWC2::Error::None;
+}
+
+#endif
+
 #if __ANDROID_API__ > 29
 HWC2::Error HwcDisplay::GetDisplayConnectionType(uint32_t *outType) {
   if (IsInHeadlessMode()) {
@@ -964,10 +1071,26 @@ HWC2::Error HwcDisplay::SetDisplayBrightness(float /* brightness */) {
   return HWC2::Error::Unsupported;
 }
 
+HWC2::Error HwcDisplay::SetReadbackBuffer(buffer_handle_t /*buffer*/, int32_t /*releaseFence*/) {
+  return HWC2::Error::Unsupported;
+}
+
 #endif /* __ANDROID_API__ > 28 */
 
 #if __ANDROID_API__ > 27
 
+HWC2::Error HwcDisplay::GetPerFrameMetadataKeys(uint32_t * /*num_elements*/, int32_t * /*keys*/) {
+    return HWC2::Error::Unsupported;
+}
+
+HWC2::Error HwcDisplay::GetReadbackBufferAttributes(int32_t * /*format*/, int32_t * /*dataspace*/) {
+  return HWC2::Error::Unsupported;
+}
+
+HWC2::Error HwcDisplay::GetReadbackBufferFence(int32_t * /*fence*/) {
+  return HWC2::Error::Unsupported;
+}
+
 HWC2::Error HwcDisplay::GetRenderIntents(
     int32_t mode, uint32_t *outNumIntents,
     int32_t * /*android_render_intent_v1_1_t*/ outIntents) {
diff --git a/hwc2_device/HwcDisplay.h b/hwc2_device/HwcDisplay.h
index bf95c3e..049fd4d 100644
--- a/hwc2_device/HwcDisplay.h
+++ b/hwc2_device/HwcDisplay.h
@@ -30,6 +30,10 @@
 #include "drm/VSyncWorker.h"
 #include "hwc2_device/HwcLayer.h"
 
+#if __ANDROID_API__ > 32
+#include "Hwc3Types.h"
+#endif
+
 namespace android {
 
 class Backend;
@@ -72,6 +76,9 @@ class HwcDisplay {
                                  int32_t *layer_requests);
   HWC2::Error GetDisplayType(int32_t *type);
 #if __ANDROID_API__ > 27
+  HWC2::Error GetPerFrameMetadataKeys(uint32_t *num_elements, int32_t *keys);
+  HWC2::Error GetReadbackBufferAttributes(int32_t *format, int32_t *dataspace);
+  HWC2::Error GetReadbackBufferFence(int32_t *fence);
   HWC2::Error GetRenderIntents(int32_t mode, uint32_t *outNumIntents,
                                int32_t *outIntents);
   HWC2::Error SetColorModeWithIntent(int32_t mode, int32_t intent);
@@ -84,6 +91,7 @@ class HwcDisplay {
                                      uint32_t *outCapabilities);
   HWC2::Error GetDisplayBrightnessSupport(bool *supported);
   HWC2::Error SetDisplayBrightness(float);
+  HWC2::Error SetReadbackBuffer(buffer_handle_t buffer, int32_t releaseFence);
 #endif
 #if __ANDROID_API__ > 29
   HWC2::Error GetDisplayConnectionType(uint32_t *outType);
@@ -99,6 +107,19 @@ class HwcDisplay {
 
   HWC2::Error SetContentType(int32_t contentType);
 #endif
+#if __ANDROID_API__ > 32
+  HWC2::Error GetMountOrientation(HwcMountOrientation *orientation);
+  HWC2::Error GetRCDLayerSupport(bool *supported) const;
+  HWC2::Error SetExpectedPresentTime(uint64_t presentTime);
+  HWC2::Error GetDisplayIdleTimerSupport(bool *supported);
+  HWC2::Error SetBootDisplayConfig(int32_t configId);
+  HWC2::Error ClearBootDisplayConfig();
+  HWC2::Error GetPreferredBootDisplayConfig(int32_t *outConfigId);
+  HWC2::Error GetClientTargetProperty(
+                        hwc_client_target_property_t *outClientTargetProperty,
+                        HwcDimmingStage *outDimmingStage);
+#endif
+
   HWC2::Error GetDisplayVsyncPeriod(uint32_t *outVsyncPeriod);
 
   HWC2::Error GetDozeSupport(int32_t *support);
@@ -223,11 +244,15 @@ class HwcDisplay {
   Stats prev_stats_;
   std::string DumpDelta(HwcDisplay::Stats delta);
 
+  HwcMountOrientation mount_orientation_ = HwcMountOrientation::ROT_0;
+  std::optional<uint64_t> expected_present_time_;
+
   void SetColorMarixToIdentity();
 
   HWC2::Error Init();
 
   HWC2::Error SetActiveConfigInternal(uint32_t config, int64_t change_time);
+  void UpdateMountOrientation();
 };
 
 }  // namespace android
diff --git a/hwc2_device/HwcLayer.cpp b/hwc2_device/HwcLayer.cpp
index dd5359f..3b6af60 100644
--- a/hwc2_device/HwcLayer.cpp
+++ b/hwc2_device/HwcLayer.cpp
@@ -292,4 +292,42 @@ void HwcLayer::SwChainClearCache() {
   swchain_reassembled_ = false;
 }
 
-}  // namespace android
\ No newline at end of file
+#if __ANDROID_API__ > 27
+HWC2::Error HwcLayer::SetLayerPerFrameMetadata(uint32_t /* numElements */,
+                                               const int32_t* /* keys */,
+                                               const float* /* metadata */) {
+  return HWC2::Error::Unsupported;
+}
+#endif /* __ANDROID_API__ > 27 */
+
+#if __ANDROID_API__ > 28
+HWC2::Error HwcLayer::SetLayerColorTransform(const float* /*matrix*/) {
+  return HWC2::Error::Unsupported;
+}
+
+HWC2::Error HwcLayer::SetLayerPerFrameMetadataBlobs(uint32_t /* numElements */,
+                                                    const int32_t* /* keys */,
+                                                    const uint32_t* /* sizes */,
+                                                    const uint8_t* /* metadata */) {
+  return HWC2::Error::Unsupported;
+
+}
+#endif /* __ANDROID_API__ > 28 */
+
+#if __ANDROID_API__ > 32
+
+HWC2::Error HwcLayer::SetLayerBrightness(float brightness) {
+  if (std::isnan(brightness) || brightness < 0.f || brightness > 1.f) {
+      ALOGE("%s Brightness is out of [0, 1] range: %f", __func__, brightness);
+      return HWC2::Error::BadParameter;
+  }
+
+  if (brightness_ != brightness) {
+      brightness_ = brightness;
+  }
+  return HWC2::Error::None;
+}
+
+#endif /* __ANDROID_API__ > 32 */
+
+}  // namespace android
diff --git a/hwc2_device/HwcLayer.h b/hwc2_device/HwcLayer.h
index b69ce5b..ab70f85 100644
--- a/hwc2_device/HwcLayer.h
+++ b/hwc2_device/HwcLayer.h
@@ -77,6 +77,22 @@ class HwcLayer {
   HWC2::Error SetLayerVisibleRegion(hwc_region_t visible);
   HWC2::Error SetLayerZOrder(uint32_t order);
 
+#if __ANDROID_API__ > 27
+  HWC2::Error SetLayerPerFrameMetadata(uint32_t numElements,
+                                       const int32_t* keys,
+                                       const float* metadata);
+#endif
+#if __ANDROID_API__ > 28
+  HWC2::Error SetLayerColorTransform(const float* matrix);
+  HWC2::Error SetLayerPerFrameMetadataBlobs(uint32_t numElements,
+                                            const int32_t *keys,
+                                            const uint32_t* sizes,
+                                            const uint8_t* metadata);
+#endif
+#if __ANDROID_API__ > 32
+  HWC2::Error SetLayerBrightness(float brightness);
+#endif
+
  private:
   // sf_type_ stores the initial type given to us by surfaceflinger,
   // validated_type_ stores the type after running ValidateDisplay
@@ -96,6 +112,7 @@ class HwcLayer {
   BufferColorSpace color_space_{};
   BufferSampleRange sample_range_{};
   BufferBlendMode blend_mode_{};
+  float brightness_{};
   buffer_handle_t buffer_handle_{};
   bool buffer_handle_updated_{};
 
diff --git a/hwc2_device/hwc2_device.cpp b/hwc2_device/hwc2_device.cpp
index d4ee10d..4de679b 100644
--- a/hwc2_device/hwc2_device.cpp
+++ b/hwc2_device/hwc2_device.cpp
@@ -245,6 +245,20 @@ static hwc2_function_pointer_t HookDevGetFunction(struct hwc2_device * /*dev*/,
           DisplayHook<decltype(&HwcDisplay::ValidateDisplay),
                       &HwcDisplay::ValidateDisplay, uint32_t *, uint32_t *>);
 #if __ANDROID_API__ > 27
+    case HWC2::FunctionDescriptor::GetPerFrameMetadataKeys:
+      return ToHook<HWC2_PFN_GET_PER_FRAME_METADATA_KEYS>(
+          DisplayHook<decltype(&HwcDisplay::GetPerFrameMetadataKeys),
+                      &HwcDisplay::GetPerFrameMetadataKeys, uint32_t *,
+                      int32_t *>);
+    case HWC2::FunctionDescriptor::GetReadbackBufferAttributes:
+      return ToHook<HWC2_PFN_GET_READBACK_BUFFER_ATTRIBUTES>(
+          DisplayHook<decltype(&HwcDisplay::GetReadbackBufferAttributes),
+                      &HwcDisplay::GetReadbackBufferAttributes, int32_t *,
+                      int32_t *>);
+    case HWC2::FunctionDescriptor::GetReadbackBufferFence:
+      return ToHook<HWC2_PFN_GET_READBACK_BUFFER_FENCE>(
+          DisplayHook<decltype(&HwcDisplay::GetReadbackBufferFence),
+                      &HwcDisplay::GetReadbackBufferFence, int32_t *>);
     case HWC2::FunctionDescriptor::GetRenderIntents:
       return ToHook<HWC2_PFN_GET_RENDER_INTENTS>(
           DisplayHook<decltype(&HwcDisplay::GetRenderIntents),
@@ -363,6 +377,22 @@ static hwc2_function_pointer_t HookDevGetFunction(struct hwc2_device * /*dev*/,
       return ToHook<HWC2_PFN_SET_LAYER_Z_ORDER>(
           LayerHook<decltype(&HwcLayer::SetLayerZOrder),
                     &HwcLayer::SetLayerZOrder, uint32_t>);
+    case HWC2::FunctionDescriptor::SetLayerPerFrameMetadata:
+      return ToHook<HWC2_PFN_SET_LAYER_PER_FRAME_METADATA>(
+          LayerHook<decltype(&HwcLayer::SetLayerPerFrameMetadata),
+                    &HwcLayer::SetLayerPerFrameMetadata, uint32_t,
+                    const int32_t *, const float *>);
+#if __ANDROID_API__ > 28
+    case HWC2::FunctionDescriptor::SetLayerColorTransform:
+      return ToHook<HWC2_PFN_SET_LAYER_COLOR_TRANSFORM>(
+          LayerHook<decltype(&HwcLayer::SetLayerColorTransform),
+                    &HwcLayer::SetLayerColorTransform, const float *>);
+    case HWC2::FunctionDescriptor::SetLayerPerFrameMetadataBlobs:
+      return ToHook<HWC2_PFN_SET_LAYER_PER_FRAME_METADATA_BLOBS>(
+          LayerHook<decltype(&HwcLayer::SetLayerPerFrameMetadataBlobs),
+                    &HwcLayer::SetLayerPerFrameMetadataBlobs, uint32_t,
+                    const int32_t *, const uint32_t *, const uint8_t *>);
+#endif
     case HWC2::FunctionDescriptor::Invalid:
     default:
       return nullptr;
diff --git a/hwc3/Android.bp b/hwc3/Android.bp
new file mode 100644
index 0000000..e9b0c18
--- /dev/null
+++ b/hwc3/Android.bp
@@ -0,0 +1,60 @@
+// Copyright (C) 2015 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+cc_defaults {
+    name: "hwcomposer3.drm_defaults",
+    defaults: ["hwcomposer.drm_defaults"],
+
+    shared_libs: [
+        "android.hardware.graphics.composer3-V1-ndk",
+        "android.hardware.graphics.composer@2.1-resources",
+        "android.hardware.graphics.composer@2.2-resources",
+        "libbinder",
+        "libbinder_ndk",
+    ],
+
+    static_libs:[
+        "libaidlcommonsupport",
+    ],
+
+    header_libs:[
+        "android.hardware.graphics.composer3-command-buffer",
+    ],
+
+    cflags: [
+        "-Wextra",
+        "-Wno-error=sign-compare",
+        "-DUSE_AIDL",
+    ],
+}
+
+filegroup {
+    name: "drm_hwcomposer3_common",
+    srcs: [
+        ":drm_hwcomposer_common",
+        "Composer.cpp",
+        "ComposerClient.cpp",
+        "ComposerCommandEngine.cpp",
+        "impl/HalImpl.cpp",
+        "impl/ResourceManager.cpp",
+        "service.cpp",
+    ],
+}
+
+cc_library_static {
+    name: "drm_hwcomposer3",
+    defaults: ["hwcomposer3.drm_defaults"],
+    srcs: [":drm_hwcomposer3_common"],
+}
+
diff --git a/hwc3/Composer.cpp b/hwc3/Composer.cpp
new file mode 100644
index 0000000..b58fbc3
--- /dev/null
+++ b/hwc3/Composer.cpp
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+#define LOG_TAG "hwc3"
+
+#include <android-base/logging.h>
+#include <android/binder_ibinder_platform.h>
+
+#include "Composer.h"
+#include "Util.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+ndk::ScopedAStatus Composer::createClient(std::shared_ptr<IComposerClient>* outClient) {
+    DEBUG_FUNC();
+    std::unique_lock<std::mutex> lock(mClientMutex);
+    if (!waitForClientDestroyedLocked(lock)) {
+        *outClient = nullptr;
+        return TO_BINDER_STATUS(EX_NO_RESOURCES);
+    }
+
+    auto client = ndk::SharedRefBase::make<ComposerClient>(mHal.get());
+    if (!client || !client->init()) {
+        *outClient = nullptr;
+        return TO_BINDER_STATUS(EX_NO_RESOURCES);
+    }
+
+    auto clientDestroyed = [this]() { onClientDestroyed(); };
+    client->setOnClientDestroyed(clientDestroyed);
+
+    mClientAlive = true;
+    *outClient = client;
+
+    return ndk::ScopedAStatus::ok();
+}
+
+binder_status_t Composer::dump(int fd, const char** /*args*/, uint32_t /*numArgs*/) {
+    std::string output;
+    mHal->dumpDebugInfo(&output);
+    write(fd, output.c_str(), output.size());
+    return STATUS_OK;
+}
+
+ndk::ScopedAStatus Composer::getCapabilities(std::vector<Capability>* caps) {
+    DEBUG_FUNC();
+    mHal->getCapabilities(caps);
+    return ndk::ScopedAStatus::ok();
+}
+
+bool Composer::waitForClientDestroyedLocked(std::unique_lock<std::mutex>& lock) {
+    if (mClientAlive) {
+        using namespace std::chrono_literals;
+
+        // In surface flinger we delete a composer client on one thread and
+        // then create a new client on another thread. Although surface
+        // flinger ensures the calls are made in that sequence (destroy and
+        // then create), sometimes the calls land in the composer service
+        // inverted (create and then destroy). Wait for a brief period to
+        // see if the existing client is destroyed.
+        LOG(DEBUG) << "waiting for previous client to be destroyed";
+        mClientDestroyedCondition.wait_for(lock, 1s,
+                                           [this]() -> bool { return !mClientAlive; });
+        if (mClientAlive) {
+            LOG(DEBUG) << "previous client was not destroyed";
+        }
+    }
+
+    return !mClientAlive;
+}
+
+void Composer::onClientDestroyed() {
+    std::lock_guard<std::mutex> lock(mClientMutex);
+    mClientAlive = false;
+    mClientDestroyedCondition.notify_all();
+}
+
+::ndk::SpAIBinder Composer::createBinder() {
+    auto binder = BnComposer::createBinder();
+    AIBinder_setInheritRt(binder.get(), true);
+    return binder;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
+
diff --git a/hwc3/Composer.h b/hwc3/Composer.h
new file mode 100644
index 0000000..9324c0b
--- /dev/null
+++ b/hwc3/Composer.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <aidl/android/hardware/graphics/composer3/BnComposer.h>
+#include <utils/Mutex.h>
+
+#include "include/IComposerHal.h"
+#include "ComposerClient.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class Composer : public BnComposer {
+public:
+    Composer(std::unique_ptr<IComposerHal> hal) : mHal(std::move(hal)) {}
+
+    binder_status_t dump(int fd, const char** args, uint32_t numArgs) override;
+
+    // compser3 api
+    ndk::ScopedAStatus createClient(std::shared_ptr<IComposerClient>* client) override;
+    ndk::ScopedAStatus getCapabilities(std::vector<Capability>* caps) override;
+
+protected:
+    ::ndk::SpAIBinder createBinder() override;
+
+private:
+    bool waitForClientDestroyedLocked(std::unique_lock<std::mutex>& lock);
+    void onClientDestroyed();
+
+    const std::unique_ptr<IComposerHal> mHal;
+    std::mutex mClientMutex;
+    bool mClientAlive GUARDED_BY(mClientMutex) = false;
+    std::condition_variable mClientDestroyedCondition;
+};
+
+}  // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/ComposerClient.cpp b/hwc3/ComposerClient.cpp
new file mode 100644
index 0000000..cc0e88c
--- /dev/null
+++ b/hwc3/ComposerClient.cpp
@@ -0,0 +1,578 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+#define LOG_TAG "hwc3-client"
+
+#include <android-base/logging.h>
+#include <android/binder_ibinder_platform.h>
+#include "ComposerClient.h"
+
+#include "ComposerClient.h"
+#include "Util.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+bool ComposerClient::init() {
+    DEBUG_FUNC();
+    mResources = IResourceManager::create();
+    if (!mResources) {
+        LOG(ERROR) << "failed to create composer resources";
+        return false;
+    }
+
+    mCommandEngine = std::make_unique<ComposerCommandEngine>(mHal, mResources.get());
+    if (mCommandEngine == nullptr) {
+        return false;
+    }
+    if (!mCommandEngine->init()) {
+        mCommandEngine = nullptr;
+        return false;
+    }
+
+    return true;
+}
+
+ComposerClient::~ComposerClient() {
+    DEBUG_FUNC();
+    // not initialized
+    if (!mCommandEngine) {
+        return;
+    }
+
+    LOG(DEBUG) << "destroying composer client";
+
+    mHal->unregisterEventCallback();
+    destroyResources();
+
+    if (mOnClientDestroyed) {
+        mOnClientDestroyed();
+    }
+
+    LOG(DEBUG) << "removed composer client";
+}
+
+// no need to check nullptr for output parameter, the aidl stub code won't pass nullptr
+ndk::ScopedAStatus ComposerClient::createLayer(int64_t display, int32_t bufferSlotCount,
+                                               int64_t* layer) {
+    DEBUG_FUNC();
+    auto err = mHal->createLayer(display, layer);
+    if (!err) {
+        err = mResources->addLayer(display, *layer, bufferSlotCount);
+        if (err) {
+            layer = 0;
+        }
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::createVirtualDisplay(int32_t width, int32_t height,
+                                                        AidlPixelFormat formatHint,
+                                                        int32_t outputBufferSlotCount,
+                                                        VirtualDisplay* display) {
+    DEBUG_FUNC();
+    auto err = mHal->createVirtualDisplay(width, height, formatHint, display);
+    if (!err) {
+        err = mResources->addVirtualDisplay(display->display, outputBufferSlotCount);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::destroyLayer(int64_t display, int64_t layer) {
+    DEBUG_FUNC();
+    auto err = mHal->destroyLayer(display, layer);
+    if (!err) {
+        err = mResources->removeLayer(display, layer);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::destroyVirtualDisplay(int64_t display) {
+    DEBUG_FUNC();
+    auto err = mHal->destroyVirtualDisplay(display);
+    if (!err) {
+        err = mResources->removeDisplay(display);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::executeCommands(const std::vector<DisplayCommand>& commands,
+                                                   std::vector<CommandResultPayload>* results) {
+    DEBUG_FUNC();
+    auto err = mCommandEngine->execute(commands, results);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getActiveConfig(int64_t display, int32_t* config) {
+    DEBUG_FUNC();
+    auto err = mHal->getActiveConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getColorModes(int64_t display,
+                                                 std::vector<ColorMode>* colorModes) {
+    DEBUG_FUNC();
+    auto err = mHal->getColorModes(display, colorModes);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                                                std::vector<float>* matrix) {
+    DEBUG_FUNC();
+    if (dataspace != common::Dataspace::SRGB_LINEAR) {
+        return TO_BINDER_STATUS(EX_BAD_PARAMETER);
+    }
+
+    auto err = mHal->getDataspaceSaturationMatrix(dataspace, matrix);
+    if (err) {
+        constexpr std::array<float, 16> unit {
+                1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
+                0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
+        };
+        matrix->clear();
+        matrix->insert(matrix->begin(), unit.begin(), unit.end());
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayAttribute(int64_t display, int32_t config,
+                                                       DisplayAttribute attribute, int32_t* value) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayAttribute(display, config, attribute, value);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayCapabilities(int64_t display,
+                                                          std::vector<DisplayCapability>* caps) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayCapabilities(display, caps);
+    if (err) {
+        return TO_BINDER_STATUS(err);
+    }
+
+    bool support = false;
+    err = mHal->getDisplayIdleTimerSupport(display, support);
+    if (err != ::android::OK) {
+        LOG(ERROR) << "failed to getDisplayIdleTimerSupport: " << err;
+    }
+
+    if (support) {
+        caps->push_back(DisplayCapability::DISPLAY_IDLE_TIMER);
+    }
+
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayConfigs(int64_t display,
+                                                     std::vector<int32_t>* configs) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayConfigs(display, configs);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayConnectionType(int64_t display,
+                                                            DisplayConnectionType* type) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayConnectionType(display, type);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayIdentificationData(int64_t display,
+                                                                DisplayIdentification* id) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayIdentificationData(display, id);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayName(int64_t display, std::string* name) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayName(display, name);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayVsyncPeriod(int64_t display, int32_t* vsyncPeriod) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayVsyncPeriod(display, vsyncPeriod);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayedContentSample(int64_t display, int64_t maxFrames,
+                                                             int64_t timestamp,
+                                                             DisplayContentSample* samples) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayedContentSample(display, maxFrames, timestamp, samples);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayedContentSamplingAttributes(
+        int64_t display, DisplayContentSamplingAttributes* attrs) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayedContentSamplingAttributes(display, attrs);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayPhysicalOrientation(int64_t display,
+                                                                 common::Transform* orientation) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayPhysicalOrientation(display, orientation);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getHdrCapabilities(int64_t display, HdrCapabilities* caps) {
+    DEBUG_FUNC();
+    auto err = mHal->getHdrCapabilities(display, caps);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getMaxVirtualDisplayCount(int32_t* count) {
+    DEBUG_FUNC();
+    auto err = mHal->getMaxVirtualDisplayCount(count);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getPerFrameMetadataKeys(int64_t display,
+                                                           std::vector<PerFrameMetadataKey>* keys) {
+    DEBUG_FUNC();
+    auto err = mHal->getPerFrameMetadataKeys(display, keys);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getReadbackBufferAttributes(int64_t display,
+                                                               ReadbackBufferAttributes* attrs) {
+    DEBUG_FUNC();
+    auto err = mHal->getReadbackBufferAttributes(display, attrs);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getReadbackBufferFence(int64_t display,
+                                                          ndk::ScopedFileDescriptor* acquireFence) {
+    DEBUG_FUNC();
+    auto err = mHal->getReadbackBufferFence(display, acquireFence);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getRenderIntents(int64_t display, ColorMode mode,
+                                                    std::vector<RenderIntent>* intents) {
+    DEBUG_FUNC();
+    auto err = mHal->getRenderIntents(display, mode, intents);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getSupportedContentTypes(int64_t display,
+                                                            std::vector<ContentType>* types) {
+    DEBUG_FUNC();
+    auto err = mHal->getSupportedContentTypes(display, types);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayDecorationSupport(
+        int64_t display, std::optional<common::DisplayDecorationSupport>* supportStruct) {
+    DEBUG_FUNC();
+    bool support = false;
+    auto err = mHal->getRCDLayerSupport(display, support);
+    if (err != ::android::OK) {
+        LOG(ERROR) << "failed to getRCDLayerSupport: " << err;
+    }
+    if (support) {
+        // TODO (b/218499393): determine from mHal instead of hard coding.
+        auto& s = supportStruct->emplace();
+        s.format = common::PixelFormat::R_8;
+        s.alphaInterpretation = common::AlphaInterpretation::COVERAGE;
+    } else {
+        supportStruct->reset();
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::registerCallback(
+        const std::shared_ptr<IComposerCallback>& callback) {
+    DEBUG_FUNC();
+    // no locking as we require this function to be called only once
+    mHalEventCallback = std::make_unique<HalEventCallback>(mHal, mResources.get(), callback);
+    mHal->registerEventCallback(mHalEventCallback.get());
+    return ndk::ScopedAStatus::ok();
+}
+
+ndk::ScopedAStatus ComposerClient::setActiveConfig(int64_t display, int32_t config) {
+    DEBUG_FUNC();
+    auto err = mHal->setActiveConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setActiveConfigWithConstraints(
+        int64_t display, int32_t config, const VsyncPeriodChangeConstraints& constraints,
+        VsyncPeriodChangeTimeline* timeline) {
+    DEBUG_FUNC();
+    auto err = mHal->setActiveConfigWithConstraints(display, config, constraints, timeline);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setBootDisplayConfig(int64_t display, int32_t config) {
+    DEBUG_FUNC();
+    auto err = mHal->setBootDisplayConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::clearBootDisplayConfig(int64_t display) {
+    DEBUG_FUNC();
+    auto err = mHal->clearBootDisplayConfig(display);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getPreferredBootDisplayConfig(int64_t display, int32_t* config) {
+    DEBUG_FUNC();
+    auto err = mHal->getPreferredBootDisplayConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setAutoLowLatencyMode(int64_t display, bool on) {
+    DEBUG_FUNC();
+    auto err = mHal->setAutoLowLatencyMode(display, on);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setClientTargetSlotCount(int64_t display, int32_t count) {
+    DEBUG_FUNC();
+    auto err = mResources->setDisplayClientTargetCacheSize(display, count);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setColorMode(int64_t display, ColorMode mode,
+                                                RenderIntent intent) {
+    DEBUG_FUNC();
+    auto err = mHal->setColorMode(display, mode, intent);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setContentType(int64_t display, ContentType type) {
+    DEBUG_FUNC();
+    auto err = mHal->setContentType(display, type);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setDisplayedContentSamplingEnabled(
+        int64_t display, bool enable, FormatColorComponent componentMask, int64_t maxFrames) {
+    DEBUG_FUNC();
+    auto err = mHal->setDisplayedContentSamplingEnabled(display, enable, componentMask, maxFrames);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setPowerMode(int64_t display, PowerMode mode) {
+    DEBUG_FUNC();
+    auto err = mHal->setPowerMode(display, mode);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setReadbackBuffer(
+        int64_t display, const AidlNativeHandle& aidlBuffer,
+        const ndk::ScopedFileDescriptor& releaseFence) {
+    DEBUG_FUNC();
+    buffer_handle_t readbackBuffer;
+    // Note ownership of the buffer is not passed to resource manager.
+    buffer_handle_t buffer = ::android::makeFromAidl(aidlBuffer);
+    auto bufReleaser = mResources->createReleaser(true /* isBuffer */);
+    auto err = mResources->getDisplayReadbackBuffer(display, buffer,
+                                                    readbackBuffer, bufReleaser.get());
+    if (!err) {
+        err = mHal->setReadbackBuffer(display, readbackBuffer, releaseFence);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setVsyncEnabled(int64_t display, bool enabled) {
+    DEBUG_FUNC();
+    auto err = mHal->setVsyncEnabled(display, enabled);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setIdleTimerEnabled(int64_t display, int32_t timeout) {
+    DEBUG_FUNC();
+    auto err = mHal->setIdleTimerEnabled(display, timeout);
+    return TO_BINDER_STATUS(err);
+}
+
+void ComposerClient::HalEventCallback::onHotplug(int64_t display, bool connected) {
+    DEBUG_FUNC();
+    if (connected) {
+        if (mResources->hasDisplay(display)) {
+            // This is a subsequent hotplug "connected" for a display. This signals a
+            // display change and thus the framework may want to reallocate buffers. We
+            // need to free all cached handles, since they are holding a strong reference
+            // to the underlying buffers.
+            cleanDisplayResources(display);
+            mResources->removeDisplay(display);
+        }
+        mResources->addPhysicalDisplay(display);
+    } else {
+        mResources->removeDisplay(display);
+    }
+
+    auto ret = mCallback->onHotplug(display, connected);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onHotplug:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onRefresh(int64_t display) {
+    DEBUG_FUNC();
+    mResources->setDisplayMustValidateState(display, true);
+    auto ret = mCallback->onRefresh(display);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onRefresh:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onVsync(int64_t display, int64_t timestamp,
+                                               int32_t vsyncPeriodNanos) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onVsync(display, timestamp, vsyncPeriodNanos);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onVsync:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onVsyncPeriodTimingChanged(
+        int64_t display, const VsyncPeriodChangeTimeline& timeline) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onVsyncPeriodTimingChanged(display, timeline);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onVsyncPeriodTimingChanged:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onVsyncIdle(int64_t display) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onVsyncIdle(display);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onVsyncIdle:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onSeamlessPossible(int64_t display) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onSeamlessPossible(display);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onSealmessPossible:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::cleanDisplayResources(int64_t display) {
+    DEBUG_FUNC();
+    size_t cacheSize;
+    auto err = mResources->getDisplayClientTargetCacheSize(display, &cacheSize);
+    if (!err) {
+        for (size_t slot = 0; slot < cacheSize; slot++) {
+            // Replace the buffer slots with NULLs. Keep the old handle until it is
+            // replaced in ComposerHal, otherwise we risk leaving a dangling pointer.
+            buffer_handle_t outHandle;
+            auto bufReleaser = mResources->createReleaser(true /* isBuffer */);
+            err = mResources->getDisplayClientTarget(display, slot, /*useCache*/ true,
+                                                    /*rawHandle*/ nullptr, outHandle,
+                                                    bufReleaser.get());
+            if (err) {
+                continue;
+            }
+            const std::vector<common::Rect> damage;
+            ndk::ScopedFileDescriptor fence; // empty fence
+            common::Dataspace dataspace = common::Dataspace::UNKNOWN;
+            err = mHal->setClientTarget(display, outHandle, fence, dataspace, damage);
+            if (err) {
+                LOG(ERROR) << "Can't clean slot " << slot
+                           << " of the client target buffer cache for display" << display;
+            }
+        }
+    } else {
+        LOG(ERROR) << "Can't clean client target cache for display " << display;
+    }
+
+    err = mResources->getDisplayOutputBufferCacheSize(display, &cacheSize);
+    if (!err) {
+        for (size_t slot = 0; slot < cacheSize; slot++) {
+            // Replace the buffer slots with NULLs. Keep the old handle until it is
+            // replaced in ComposerHal, otherwise we risk leaving a dangling pointer.
+            buffer_handle_t outputBuffer;
+            auto bufReleaser = mResources->createReleaser(true /* isBuffer */);
+            err = mResources->getDisplayOutputBuffer(display, slot, /*useCache*/ true,
+                                                    /*rawHandle*/ nullptr, outputBuffer,
+                                                    bufReleaser.get());
+            if (err) {
+                continue;
+            }
+            ndk::ScopedFileDescriptor emptyFd;
+            err = mHal->setOutputBuffer(display, outputBuffer, /*fence*/ emptyFd);
+            if (err) {
+                LOG(ERROR) << "Can't clean slot " << slot
+                           << " of the output buffer cache for display " << display;
+            }
+        }
+    } else {
+        LOG(ERROR) << "Can't clean output buffer cache for display " << display;
+    }
+}
+
+void ComposerClient::destroyResources() {
+    DEBUG_FUNC();
+    // We want to call hwc2_close here (and move hwc2_open to the
+    // constructor), with the assumption that hwc2_close would
+    //
+    //  - clean up all resources owned by the client
+    //  - make sure all displays are blank (since there is no layer)
+    //
+    // But since SF used to crash at this point, different hwcomposer2
+    // implementations behave differently on hwc2_close.  Our only portable
+    // choice really is to abort().  But that is not an option anymore
+    // because we might also have VTS or VR as clients that can come and go.
+    //
+    // Below we manually clean all resources (layers and virtual
+    // displays), and perform a presentDisplay afterwards.
+    mResources->clear([this](int64_t display, bool isVirtual, const std::vector<int64_t> layers) {
+        LOG(WARNING) << "destroying client resources for display " << display;
+        for (auto layer : layers) {
+            mHal->destroyLayer(display, layer);
+        }
+
+        if (isVirtual) {
+            mHal->destroyVirtualDisplay(display);
+        } else {
+            LOG(WARNING) << "performing a final presentDisplay";
+            std::vector<int64_t> changedLayers;
+            std::vector<Composition> compositionTypes;
+            uint32_t displayRequestMask = 0;
+            std::vector<int64_t> requestedLayers;
+            std::vector<int32_t> requestMasks;
+            ClientTargetProperty clientTargetProperty;
+            DimmingStage dimmingStage;
+            mHal->validateDisplay(display, &changedLayers, &compositionTypes, &displayRequestMask,
+                                  &requestedLayers, &requestMasks, &clientTargetProperty,
+                                  &dimmingStage);
+            mHal->acceptDisplayChanges(display);
+
+            ndk::ScopedFileDescriptor presentFence;
+            std::vector<int64_t> releasedLayers;
+            std::vector<ndk::ScopedFileDescriptor> releaseFences;
+            mHal->presentDisplay(display, presentFence, &releasedLayers, &releaseFences);
+        }
+    });
+    mResources.reset();
+}
+
+::ndk::SpAIBinder ComposerClient::createBinder() {
+    auto binder = BnComposerClient::createBinder();
+    AIBinder_setInheritRt(binder.get(), true);
+    return binder;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/ComposerClient.h b/hwc3/ComposerClient.h
new file mode 100644
index 0000000..855fb8b
--- /dev/null
+++ b/hwc3/ComposerClient.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <aidl/android/hardware/graphics/common/DisplayDecorationSupport.h>
+#include <aidl/android/hardware/graphics/composer3/BnComposerClient.h>
+#include <utils/Mutex.h>
+
+#include <memory>
+
+#include "ComposerCommandEngine.h"
+#include "include/IComposerHal.h"
+#include "include/IResourceManager.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class ComposerClient : public BnComposerClient {
+public:
+    ComposerClient(IComposerHal* hal) : mHal(hal) {}
+    virtual ~ComposerClient();
+    bool init();
+    void setOnClientDestroyed(std::function<void()> onClientDestroyed) {
+        mOnClientDestroyed = onClientDestroyed;
+    }
+
+    class HalEventCallback : public IComposerHal::EventCallback {
+      public:
+          HalEventCallback(IComposerHal* hal, IResourceManager* resources,
+                           const std::shared_ptr<IComposerCallback>& callback)
+                : mHal(hal), mResources(resources), mCallback(callback) {}
+          void onHotplug(int64_t display, bool connected) override;
+          void onRefresh(int64_t display) override;
+          void onVsync(int64_t display, int64_t timestamp, int32_t vsyncPeriodNanos) override;
+          void onVsyncPeriodTimingChanged(int64_t display,
+                                          const VsyncPeriodChangeTimeline& timeline) override;
+          void onVsyncIdle(int64_t display) override;
+          void onSeamlessPossible(int64_t display) override;
+
+      private:
+        void cleanDisplayResources(int64_t display);
+
+        IComposerHal* mHal;
+        IResourceManager* mResources;
+        const std::shared_ptr<IComposerCallback> mCallback;
+    };
+
+    // composer3 interface
+    ndk::ScopedAStatus createLayer(int64_t display, int32_t bufferSlotCount,
+                                   int64_t* layer) override;
+    ndk::ScopedAStatus createVirtualDisplay(int32_t width, int32_t height,
+                                            AidlPixelFormat formatHint,
+                                            int32_t outputBufferSlotCount,
+                                            VirtualDisplay* display) override;
+    ndk::ScopedAStatus destroyLayer(int64_t display, int64_t layer) override;
+    ndk::ScopedAStatus destroyVirtualDisplay(int64_t display) override;
+    ndk::ScopedAStatus executeCommands(const std::vector<DisplayCommand>& commands,
+                                       std::vector<CommandResultPayload>* results) override;
+    ndk::ScopedAStatus getActiveConfig(int64_t display, int32_t* config) override;
+    ndk::ScopedAStatus getColorModes(int64_t display, std::vector<ColorMode>* colorModes) override;
+    ndk::ScopedAStatus getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                                    std::vector<float>* matrix) override;
+    ndk::ScopedAStatus getDisplayAttribute(int64_t display, int32_t config,
+                                           DisplayAttribute attribute, int32_t* value) override;
+    ndk::ScopedAStatus getDisplayCapabilities(int64_t display,
+                                              std::vector<DisplayCapability>* caps) override;
+    ndk::ScopedAStatus getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) override;
+    ndk::ScopedAStatus getDisplayConnectionType(int64_t display,
+                                                DisplayConnectionType* type) override;
+    ndk::ScopedAStatus getDisplayIdentificationData(int64_t display,
+                                                    DisplayIdentification* id) override;
+    ndk::ScopedAStatus getDisplayName(int64_t display, std::string* name) override;
+    ndk::ScopedAStatus getDisplayVsyncPeriod(int64_t display, int32_t* vsyncPeriod) override;
+    ndk::ScopedAStatus getDisplayedContentSample(int64_t display, int64_t maxFrames,
+                                                 int64_t timestamp,
+                                                 DisplayContentSample* samples) override;
+    ndk::ScopedAStatus getDisplayedContentSamplingAttributes(
+            int64_t display, DisplayContentSamplingAttributes* attrs) override;
+    ndk::ScopedAStatus getDisplayPhysicalOrientation(int64_t display,
+                                                     common::Transform* orientation) override;
+    ndk::ScopedAStatus getHdrCapabilities(int64_t display, HdrCapabilities* caps) override;
+    ndk::ScopedAStatus getMaxVirtualDisplayCount(int32_t* count) override;
+    ndk::ScopedAStatus getPerFrameMetadataKeys(int64_t display,
+                                               std::vector<PerFrameMetadataKey>* keys) override;
+    ndk::ScopedAStatus getReadbackBufferAttributes(int64_t display,
+                                                   ReadbackBufferAttributes* attrs) override;
+    ndk::ScopedAStatus getReadbackBufferFence(int64_t display,
+                                              ndk::ScopedFileDescriptor* acquireFence) override;
+    ndk::ScopedAStatus getRenderIntents(int64_t display, ColorMode mode,
+                                        std::vector<RenderIntent>* intents) override;
+    ndk::ScopedAStatus getSupportedContentTypes(int64_t display,
+                                                std::vector<ContentType>* types) override;
+    ndk::ScopedAStatus getDisplayDecorationSupport(
+            int64_t display, std::optional<common::DisplayDecorationSupport>* support) override;
+    ndk::ScopedAStatus registerCallback(
+            const std::shared_ptr<IComposerCallback>& callback) override;
+    ndk::ScopedAStatus setActiveConfig(int64_t display, int32_t config) override;
+    ndk::ScopedAStatus setActiveConfigWithConstraints(
+            int64_t display, int32_t config, const VsyncPeriodChangeConstraints& constraints,
+            VsyncPeriodChangeTimeline* timeline) override;
+    ndk::ScopedAStatus setBootDisplayConfig(int64_t display, int32_t config) override;
+    ndk::ScopedAStatus clearBootDisplayConfig(int64_t display) override;
+    ndk::ScopedAStatus getPreferredBootDisplayConfig(int64_t display, int32_t* config) override;
+    ndk::ScopedAStatus setAutoLowLatencyMode(int64_t display, bool on) override;
+    ndk::ScopedAStatus setClientTargetSlotCount(int64_t display, int32_t count) override;
+    ndk::ScopedAStatus setColorMode(int64_t display, ColorMode mode, RenderIntent intent) override;
+    ndk::ScopedAStatus setContentType(int64_t display, ContentType type) override;
+    ndk::ScopedAStatus setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                                          FormatColorComponent componentMask,
+                                                          int64_t maxFrames) override;
+    ndk::ScopedAStatus setPowerMode(int64_t display, PowerMode mode) override;
+    ndk::ScopedAStatus setReadbackBuffer(int64_t display, const AidlNativeHandle& buffer,
+                                         const ndk::ScopedFileDescriptor& releaseFence) override;
+    ndk::ScopedAStatus setVsyncEnabled(int64_t display, bool enabled) override;
+    ndk::ScopedAStatus setIdleTimerEnabled(int64_t display, int32_t timeout) override;
+
+protected:
+    ::ndk::SpAIBinder createBinder() override;
+
+private:
+    void destroyResources();
+
+    IComposerHal* mHal;
+    std::unique_ptr<IResourceManager> mResources;
+    std::unique_ptr<ComposerCommandEngine> mCommandEngine;
+    std::function<void()> mOnClientDestroyed;
+    std::unique_ptr<HalEventCallback> mHalEventCallback;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
+
diff --git a/hwc3/ComposerCommandEngine.cpp b/hwc3/ComposerCommandEngine.cpp
new file mode 100644
index 0000000..31cb72f
--- /dev/null
+++ b/hwc3/ComposerCommandEngine.cpp
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "hwc3-command-engine"
+
+#include <set>
+#include <android-base/logging.h>
+
+#include "ComposerCommandEngine.h"
+#include "Util.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+#define DISPATCH_LAYER_COMMAND(display, layerCmd, field, funcName)               \
+    do {                                                                         \
+        if (layerCmd.field) {                                                    \
+            executeSetLayer##funcName(display, layerCmd.layer, *layerCmd.field); \
+        }                                                                        \
+    } while (0)
+
+#define DISPATCH_LAYER_COMMAND_SIMPLE(display, layerCmd, field, funcName)     \
+    do {                                                                      \
+        dispatchLayerCommand(display, layerCmd.layer, #field, layerCmd.field, \
+                             &IComposerHal::setLayer##funcName);              \
+    } while (0)
+
+#define DISPATCH_DISPLAY_COMMAND(displayCmd, field, funcName)                \
+    do {                                                                     \
+        if (displayCmd.field) {                                              \
+            execute##funcName(displayCmd.display, *displayCmd.field);        \
+        }                                                                    \
+    } while (0)
+
+#define DISPATCH_DISPLAY_BOOL_COMMAND(displayCmd, field, funcName)           \
+    do {                                                                     \
+        if (displayCmd.field) {                                              \
+            execute##funcName(displayCmd.display);                           \
+        }                                                                    \
+    } while (0)
+
+#define DISPATCH_DISPLAY_BOOL_COMMAND_AND_DATA(displayCmd, field, data, funcName) \
+    do {                                                                          \
+        if (displayCmd.field) {                                                   \
+            execute##funcName(displayCmd.display, displayCmd.data);               \
+        }                                                                         \
+    } while (0)
+
+bool ComposerCommandEngine::init() {
+    mWriter = std::make_unique<ComposerServiceWriter>();
+    return (mWriter != nullptr);
+}
+
+int32_t ComposerCommandEngine::execute(const std::vector<DisplayCommand>& commands,
+                                       std::vector<CommandResultPayload>* result) {
+    std::set<int64_t> displaysPendingBrightnessChange;
+    mCommandIndex = 0;
+    for (const auto& command : commands) {
+        dispatchDisplayCommand(command);
+        ++mCommandIndex;
+        // The input commands could have 2+ commands for the same display.
+        // If the first has pending brightness change, the second presentDisplay will apply it.
+        if (command.validateDisplay || command.presentDisplay ||
+            command.presentOrValidateDisplay) {
+            displaysPendingBrightnessChange.erase(command.display);
+        } else if (command.brightness) {
+            displaysPendingBrightnessChange.insert(command.display);
+        }
+    }
+
+    *result = mWriter->getPendingCommandResults();
+    mWriter->reset();
+
+    return ::android::NO_ERROR;
+}
+
+void ComposerCommandEngine::dispatchDisplayCommand(const DisplayCommand& command) {
+    //  place SetDisplayBrightness before SetLayerWhitePointNits since current
+    //  display brightness is used to validate the layer white point nits.
+    DISPATCH_DISPLAY_COMMAND(command, brightness, SetDisplayBrightness);
+    for (const auto& layerCmd : command.layers) {
+        dispatchLayerCommand(command.display, layerCmd);
+    }
+
+    DISPATCH_DISPLAY_COMMAND(command, colorTransformMatrix, SetColorTransform);
+    DISPATCH_DISPLAY_COMMAND(command, clientTarget, SetClientTarget);
+    DISPATCH_DISPLAY_COMMAND(command, virtualDisplayOutputBuffer, SetOutputBuffer);
+    DISPATCH_DISPLAY_BOOL_COMMAND_AND_DATA(command, validateDisplay, expectedPresentTime,
+                                           ValidateDisplay);
+    DISPATCH_DISPLAY_BOOL_COMMAND(command, acceptDisplayChanges, AcceptDisplayChanges);
+    DISPATCH_DISPLAY_BOOL_COMMAND(command, presentDisplay, PresentDisplay);
+    DISPATCH_DISPLAY_BOOL_COMMAND_AND_DATA(command, presentOrValidateDisplay, expectedPresentTime,
+                                           PresentOrValidateDisplay);
+}
+
+void ComposerCommandEngine::dispatchLayerCommand(int64_t display, const LayerCommand& command) {
+    DISPATCH_LAYER_COMMAND(display, command, cursorPosition, CursorPosition);
+    DISPATCH_LAYER_COMMAND(display, command, buffer, Buffer);
+    DISPATCH_LAYER_COMMAND(display, command, damage, SurfaceDamage);
+    DISPATCH_LAYER_COMMAND(display, command, blendMode, BlendMode);
+    DISPATCH_LAYER_COMMAND(display, command, color, Color);
+    DISPATCH_LAYER_COMMAND(display, command, composition, Composition);
+    DISPATCH_LAYER_COMMAND(display, command, dataspace, Dataspace);
+    DISPATCH_LAYER_COMMAND(display, command, displayFrame, DisplayFrame);
+    DISPATCH_LAYER_COMMAND(display, command, planeAlpha, PlaneAlpha);
+    DISPATCH_LAYER_COMMAND(display, command, sidebandStream, SidebandStream);
+    DISPATCH_LAYER_COMMAND(display, command, sourceCrop, SourceCrop);
+    DISPATCH_LAYER_COMMAND(display, command, transform, Transform);
+    DISPATCH_LAYER_COMMAND(display, command, visibleRegion, VisibleRegion);
+    DISPATCH_LAYER_COMMAND(display, command, z, ZOrder);
+    DISPATCH_LAYER_COMMAND(display, command, colorTransform, ColorTransform);
+    DISPATCH_LAYER_COMMAND(display, command, brightness, Brightness);
+    DISPATCH_LAYER_COMMAND(display, command, perFrameMetadata, PerFrameMetadata);
+    DISPATCH_LAYER_COMMAND(display, command, perFrameMetadataBlob, PerFrameMetadataBlobs);
+//    DISPATCH_LAYER_COMMAND_SIMPLE(display, command, blockingRegion, BlockingRegion);
+}
+
+int32_t ComposerCommandEngine::executeValidateDisplayInternal(int64_t display) {
+    std::vector<int64_t> changedLayers;
+    std::vector<Composition> compositionTypes;
+    uint32_t displayRequestMask = 0x0;
+    std::vector<int64_t> requestedLayers;
+    std::vector<int32_t> requestMasks;
+    ClientTargetProperty clientTargetProperty{common::PixelFormat::RGBA_8888,
+                                              common::Dataspace::UNKNOWN};
+    DimmingStage dimmingStage;
+    auto err =
+            mHal->validateDisplay(display, &changedLayers, &compositionTypes, &displayRequestMask,
+                                  &requestedLayers, &requestMasks, &clientTargetProperty,
+                                  &dimmingStage);
+    mResources->setDisplayMustValidateState(display, false);
+    if (!err) {
+        mWriter->setChangedCompositionTypes(display, changedLayers, compositionTypes);
+        mWriter->setDisplayRequests(display, displayRequestMask, requestedLayers, requestMasks);
+        static constexpr float kBrightness = 1.f;
+        mWriter->setClientTargetProperty(display, clientTargetProperty, kBrightness, dimmingStage);
+    } else {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+    return err;
+}
+
+void ComposerCommandEngine::executeSetColorTransform(int64_t display,
+                                                     const std::vector<float>& matrix) {
+    auto err = mHal->setColorTransform(display, matrix);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetClientTarget(int64_t display, const ClientTarget& command) {
+    bool useCache = !command.buffer.handle;
+    buffer_handle_t handle = useCache
+                             ? nullptr
+                             : ::android::makeFromAidl(*command.buffer.handle);
+    buffer_handle_t clientTarget;
+    auto bufferReleaser = mResources->createReleaser(true);
+    auto err = mResources->getDisplayClientTarget(display, command.buffer.slot, useCache, handle,
+                                                  clientTarget, bufferReleaser.get());
+    if (!err) {
+        err = mHal->setClientTarget(display, clientTarget, command.buffer.fence,
+                                    command.dataspace, command.damage);
+        if (err) {
+            LOG(ERROR) << __func__ << " setClientTarget: err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    } else {
+        LOG(ERROR) << __func__ << " getDisplayClientTarget : err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetOutputBuffer(uint64_t display, const Buffer& buffer) {
+    bool useCache = !buffer.handle;
+    buffer_handle_t handle = useCache
+                             ? nullptr
+                             : ::android::makeFromAidl(*buffer.handle);
+    buffer_handle_t outputBuffer;
+    auto bufferReleaser = mResources->createReleaser(true);
+    auto err = mResources->getDisplayOutputBuffer(display, buffer.slot, useCache, handle,
+                                                  outputBuffer, bufferReleaser.get());
+    if (!err) {
+        err = mHal->setOutputBuffer(display, outputBuffer, buffer.fence);
+        if (err) {
+            LOG(ERROR) << __func__ << " setOutputBuffer: err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    } else {
+        LOG(ERROR) << __func__ << " getDisplayOutputBuffer: err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetExpectedPresentTimeInternal(
+        int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    mHal->setExpectedPresentTime(display, expectedPresentTime);
+}
+
+void ComposerCommandEngine::executeValidateDisplay(
+        int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    executeSetExpectedPresentTimeInternal(display, expectedPresentTime);
+    executeValidateDisplayInternal(display);
+}
+
+void ComposerCommandEngine::executeSetDisplayBrightness(uint64_t display,
+                                        const DisplayBrightness& command) {
+    auto err = mHal->setDisplayBrightness(display, command.brightness);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executePresentOrValidateDisplay(
+        int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    executeSetExpectedPresentTimeInternal(display, expectedPresentTime);
+
+    int err;
+    // First try to Present as is.
+    if (mHal->hasCapability(Capability::SKIP_VALIDATE)) {
+        err = mResources->mustValidateDisplay(display) ? IComposerClient::EX_NOT_VALIDATED
+                                                       : executePresentDisplay(display);
+        if (!err) {
+            mWriter->setPresentOrValidateResult(display, PresentOrValidate::Result::Presented);
+            return;
+        }
+    }
+
+    // Fallback to validate
+    err = executeValidateDisplayInternal(display);
+    if (!err) {
+        mWriter->setPresentOrValidateResult(display, PresentOrValidate::Result::Validated);
+    }
+}
+
+void ComposerCommandEngine::executeAcceptDisplayChanges(int64_t display) {
+    auto err = mHal->acceptDisplayChanges(display);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+int ComposerCommandEngine::executePresentDisplay(int64_t display) {
+    ndk::ScopedFileDescriptor presentFence;
+    std::vector<int64_t> layers;
+    std::vector<ndk::ScopedFileDescriptor> fences;
+    auto err = mHal->presentDisplay(display, presentFence, &layers, &fences);
+    if (!err) {
+        mWriter->setPresentFence(display, std::move(presentFence));
+        mWriter->setReleaseFences(display, layers, std::move(fences));
+    }
+
+    return err;
+}
+
+void ComposerCommandEngine::executeSetLayerCursorPosition(int64_t display, int64_t layer,
+                                       const common::Point& cursorPosition) {
+    auto err = mHal->setLayerCursorPosition(display, layer, cursorPosition.x, cursorPosition.y);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerBuffer(int64_t display, int64_t layer,
+                                                  const Buffer& buffer) {
+    bool useCache = !buffer.handle;
+    buffer_handle_t handle = useCache
+                             ? nullptr
+                             : ::android::makeFromAidl(*buffer.handle);
+    buffer_handle_t hwcBuffer;
+    auto bufferReleaser = mResources->createReleaser(true);
+    auto err = mResources->getLayerBuffer(display, layer, buffer.slot, useCache,
+                                          handle, hwcBuffer, bufferReleaser.get());
+    if (!err) {
+        err = mHal->setLayerBuffer(display, layer, hwcBuffer, buffer.fence);
+        if (err) {
+            LOG(ERROR) << __func__ << ": setLayerBuffer err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    } else {
+        LOG(ERROR) << __func__ << ": getLayerBuffer err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerSurfaceDamage(int64_t display, int64_t layer,
+                              const std::vector<std::optional<common::Rect>>& damage) {
+    auto err = mHal->setLayerSurfaceDamage(display, layer, damage);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerBlendMode(int64_t display, int64_t layer,
+                                                     const ParcelableBlendMode& blendMode) {
+    auto err = mHal->setLayerBlendMode(display, layer, blendMode.blendMode);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerColor(int64_t display, int64_t layer,
+                                                 const Color& color) {
+    auto err = mHal->setLayerColor(display, layer, color);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerComposition(int64_t display, int64_t layer,
+                                                       const ParcelableComposition& composition) {
+    auto err = mHal->setLayerCompositionType(display, layer, composition.composition);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerDataspace(int64_t display, int64_t layer,
+                                                     const ParcelableDataspace& dataspace) {
+    auto err = mHal->setLayerDataspace(display, layer, dataspace.dataspace);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerDisplayFrame(int64_t display, int64_t layer,
+                                                        const common::Rect& rect) {
+    auto err = mHal->setLayerDisplayFrame(display, layer, rect);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerPlaneAlpha(int64_t display, int64_t layer,
+                                                      const PlaneAlpha& planeAlpha) {
+    auto err = mHal->setLayerPlaneAlpha(display, layer, planeAlpha.alpha);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerSidebandStream(int64_t display, int64_t layer,
+                                                 const AidlNativeHandle& sidebandStream) {
+    buffer_handle_t handle = ::android::makeFromAidl(sidebandStream);
+    buffer_handle_t stream;
+
+    auto bufferReleaser = mResources->createReleaser(false);
+    auto err = mResources->getLayerSidebandStream(display, layer, handle,
+                                                  stream, bufferReleaser.get());
+    if (err) {
+        err = mHal->setLayerSidebandStream(display, layer, stream);
+    }
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerSourceCrop(int64_t display, int64_t layer,
+                                                      const common::FRect& sourceCrop) {
+    auto err = mHal->setLayerSourceCrop(display, layer, sourceCrop);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerTransform(int64_t display, int64_t layer,
+                                                     const ParcelableTransform& transform) {
+    auto err = mHal->setLayerTransform(display, layer, transform.transform);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerVisibleRegion(int64_t display, int64_t layer,
+                          const std::vector<std::optional<common::Rect>>& visibleRegion) {
+    auto err = mHal->setLayerVisibleRegion(display, layer, visibleRegion);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerZOrder(int64_t display, int64_t layer,
+                                                  const ZOrder& zOrder) {
+    auto err = mHal->setLayerZOrder(display, layer, zOrder.z);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerPerFrameMetadata(int64_t display, int64_t layer,
+                const std::vector<std::optional<PerFrameMetadata>>& perFrameMetadata) {
+    auto err = mHal->setLayerPerFrameMetadata(display, layer, perFrameMetadata);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerColorTransform(int64_t display, int64_t layer,
+                                                       const std::vector<float>& matrix) {
+    auto err = mHal->setLayerColorTransform(display, layer, matrix);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerBrightness(int64_t display, int64_t layer,
+                                                      const LayerBrightness& brightness) {
+    auto err = mHal->setLayerBrightness(display, layer, brightness.brightness);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                      const std::vector<std::optional<PerFrameMetadataBlob>>& metadata) {
+    auto err = mHal->setLayerPerFrameMetadataBlobs(display, layer, metadata);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/ComposerCommandEngine.h b/hwc3/ComposerCommandEngine.h
new file mode 100644
index 0000000..ae68285
--- /dev/null
+++ b/hwc3/ComposerCommandEngine.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android/hardware/graphics/composer3/ComposerServiceWriter.h>
+#include <utils/Mutex.h>
+
+#include <memory>
+
+#include "include/IComposerHal.h"
+#include "include/IResourceManager.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class ComposerCommandEngine {
+  public:
+      ComposerCommandEngine(IComposerHal* hal, IResourceManager* resources)
+            : mHal(hal), mResources(resources) {}
+      bool init();
+
+      int32_t execute(const std::vector<DisplayCommand>& commands,
+                      std::vector<CommandResultPayload>* result);
+
+      template <typename InputType, typename Functor>
+      void dispatchLayerCommand(int64_t display, int64_t layer, const std::string& funcName,
+                                const InputType input, const Functor func);
+
+      void reset() {
+          mWriter->reset();
+      }
+
+  private:
+      void dispatchDisplayCommand(const DisplayCommand& displayCommand);
+      void dispatchLayerCommand(int64_t display, const LayerCommand& displayCommand);
+
+      void executeSetColorTransform(int64_t display, const std::vector<float>& matrix);
+      void executeSetClientTarget(int64_t display, const ClientTarget& command);
+      void executeSetDisplayBrightness(uint64_t display, const DisplayBrightness& command);
+      void executeSetOutputBuffer(uint64_t display, const Buffer& buffer);
+      void executeValidateDisplay(int64_t display,
+                                  const std::optional<ClockMonotonicTimestamp> expectedPresentTime);
+      void executePresentOrValidateDisplay(
+              int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime);
+      void executeAcceptDisplayChanges(int64_t display);
+      int executePresentDisplay(int64_t display);
+
+      void executeSetLayerCursorPosition(int64_t display, int64_t layer,
+                                         const common::Point& cursorPosition);
+      void executeSetLayerBuffer(int64_t display, int64_t layer, const Buffer& buffer);
+      void executeSetLayerSurfaceDamage(int64_t display, int64_t layer,
+                                        const std::vector<std::optional<common::Rect>>& damage);
+      void executeSetLayerBlendMode(int64_t display, int64_t layer,
+                                    const ParcelableBlendMode& blendMode);
+      void executeSetLayerColor(int64_t display, int64_t layer, const Color& color);
+      void executeSetLayerComposition(int64_t display, int64_t layer,
+                                      const ParcelableComposition& composition);
+      void executeSetLayerDataspace(int64_t display, int64_t layer,
+                                    const ParcelableDataspace& dataspace);
+      void executeSetLayerDisplayFrame(int64_t display, int64_t layer, const common::Rect& rect);
+      void executeSetLayerPlaneAlpha(int64_t display, int64_t layer, const PlaneAlpha& planeAlpha);
+      void executeSetLayerSidebandStream(int64_t display, int64_t layer,
+                                         const AidlNativeHandle& sidebandStream);
+      void executeSetLayerSourceCrop(int64_t display, int64_t layer,
+                                     const common::FRect& sourceCrop);
+      void executeSetLayerTransform(int64_t display, int64_t layer,
+                                    const ParcelableTransform& transform);
+      void executeSetLayerVisibleRegion(
+              int64_t display, int64_t layer,
+              const std::vector<std::optional<common::Rect>>& visibleRegion);
+      void executeSetLayerZOrder(int64_t display, int64_t layer, const ZOrder& zOrder);
+      void executeSetLayerPerFrameMetadata(
+              int64_t display, int64_t layer,
+              const std::vector<std::optional<PerFrameMetadata>>& perFrameMetadata);
+      void executeSetLayerColorTransform(int64_t display, int64_t layer,
+                                         const std::vector<float>& colorTransform);
+      void executeSetLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+              const std::vector<std::optional<PerFrameMetadataBlob>>& perFrameMetadataBlob);
+      void executeSetLayerBrightness(int64_t display, int64_t layer,
+                                     const LayerBrightness& brightness);
+
+      int32_t executeValidateDisplayInternal(int64_t display);
+      void executeSetExpectedPresentTimeInternal(
+              int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime);
+
+      IComposerHal* mHal;
+      IResourceManager* mResources;
+      std::unique_ptr<ComposerServiceWriter> mWriter;
+      int32_t mCommandIndex;
+};
+
+template <typename InputType, typename Functor>
+void ComposerCommandEngine::dispatchLayerCommand(int64_t display, int64_t layer,
+                                                 const std::string& funcName, const InputType input,
+                                                 const Functor func) {
+    if (input) {
+        auto err = (mHal->*func)(display, layer, *input);
+        if (err) {
+            LOG(ERROR) << funcName << ": err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    }
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
+
diff --git a/hwc3/NOTICE b/hwc3/NOTICE
new file mode 100644
index 0000000..316b4eb
--- /dev/null
+++ b/hwc3/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2014, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/hwc3/Util.h b/hwc3/Util.h
new file mode 100644
index 0000000..564e363
--- /dev/null
+++ b/hwc3/Util.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/logging.h>
+#include <string_view>
+#include <utils/Trace.h>
+
+// #define LOG_FUNC
+#define TRACE_FUNC
+
+#ifdef TRACE_FUNC
+#define DEBUG_FUNC() constexpr static FullMethodName __kFullNameObj__ =                     \
+                                           FullMethodName{ __PRETTY_FUNCTION__ };           \
+                     constexpr static const char *__kFullName__ =  __kFullNameObj__.get();  \
+                     ATRACE_NAME(__kFullName__)
+#else
+
+#ifdef LOG_FUNC
+#define DEBUG_FUNC() DebugFunction _dbgFnObj_(__func__)
+#else
+#define DEBUG_FUNC()
+#endif
+
+#endif
+
+#define RET_IF_ERR(expr)                  \
+    do {                                  \
+        auto err = (expr);                \
+        if (err) [[unlikely]] return err; \
+    } while (0)
+
+#define TO_BINDER_STATUS(x) x == 0                                                \
+                            ? ndk::ScopedAStatus::ok()                            \
+                            : ndk::ScopedAStatus::fromServiceSpecificError(x)
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class DebugFunction {
+public:
+    DebugFunction(const char* name) : mName(name) { LOG(INFO) << mName << " Enter"; }
+
+    ~DebugFunction() { LOG(INFO) << mName << " Exit"; }
+
+private:
+    const char* mName;
+};
+
+class FullMethodName {
+public:
+    constexpr FullMethodName(const std::string_view prettyName) : mBuf() {
+        // remove every thing before 'impl::'
+        auto start = prettyName.find("impl::");
+        if (start == prettyName.npos) {
+            start = 0;
+        }
+        // remove everything after '('
+        auto end = prettyName.rfind('(');
+        if (end == prettyName.npos) {
+            end = prettyName.length();
+        }
+
+        auto len = std::min(end - start, mBuf.size());
+        // to a null-terminated string
+        // prettyName.copy(mBuf.data(), len, start) is available in c++20
+        for (size_t i = 0; i < len; ++i) {
+            mBuf[i] = prettyName[start + i];
+        }
+    }
+
+    constexpr const char *get() const {
+        return mBuf.data();
+    }
+
+private:
+    std::array<char, 256> mBuf;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/impl/HalImpl.cpp b/hwc3/impl/HalImpl.cpp
new file mode 100644
index 0000000..8e1e56a
--- /dev/null
+++ b/hwc3/impl/HalImpl.cpp
@@ -0,0 +1,1479 @@
+/*
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "hwc3-impl"
+
+#include "HalImpl.h"
+
+#include <aidl/android/hardware/graphics/composer3/IComposerCallback.h>
+#include <android-base/logging.h>
+#include <hardware/hwcomposer2.h>
+
+#include "hwc2_device/DrmHwcTwo.h"
+#include "hwc2_device/HwcDisplay.h"
+#include "hwc2_device/HwcLayer.h"
+#include "TranslateHwcAidl.h"
+#include "Util.h"
+
+using namespace android;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+std::unique_ptr<IComposerHal> IComposerHal::create() {
+    auto device = std::make_unique<DrmHwcTwo>();
+    if (!device) {
+        return nullptr;
+    }
+
+    return std::make_unique<HalImpl>(std::move(device));
+}
+
+namespace hook {
+
+void hotplug(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay,
+                        int32_t connected) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onHotplug(display, connected == HWC2_CONNECTION_CONNECTED);
+}
+
+void refresh(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onRefresh(display);
+}
+
+void vsync(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay,
+                           int64_t timestamp, hwc2_vsync_period_t hwcVsyncPeriodNanos) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+    int32_t vsyncPeriodNanos;
+
+    h2a::translate(hwcDisplay, display);
+    h2a::translate(hwcVsyncPeriodNanos, vsyncPeriodNanos);
+    hal->getEventCallback()->onVsync(display, timestamp, vsyncPeriodNanos);
+}
+
+void vsyncPeriodTimingChanged(hwc2_callback_data_t callbackData,
+                                         hwc2_display_t hwcDisplay,
+                                         hwc_vsync_period_change_timeline_t* hwcTimeline) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+    VsyncPeriodChangeTimeline timeline;
+
+    h2a::translate(hwcDisplay, display);
+    h2a::translate(*hwcTimeline, timeline);
+    hal->getEventCallback()->onVsyncPeriodTimingChanged(display, timeline);
+}
+
+void vsyncIdle(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onVsyncIdle(display);
+}
+
+void seamlessPossible(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onSeamlessPossible(display);
+}
+
+} // nampesapce hook
+
+HalImpl::HalImpl(std::unique_ptr<DrmHwcTwo> device) : mDevice(std::move(device)) {
+    initCaps();
+}
+
+void HalImpl::initCaps() {
+    uint32_t count = 0;
+    mDevice->GetCapabilities(&count, nullptr);
+
+    std::vector<int32_t> halCaps(count);
+    mDevice->GetCapabilities(&count, halCaps.data());
+
+    for (auto hwcCap : halCaps) {
+        Capability cap;
+        h2a::translate(hwcCap, cap);
+        mCaps.insert(cap);
+    }
+
+    // TODO: implement [Set/Clear]BootDisplayConfig
+    // mCaps.insert(Capability::BOOT_DISPLAY_CONFIG);
+}
+
+int32_t HalImpl::getHalDisplay(int64_t display, HwcDisplay*& halDisplay) {
+    hwc2_display_t hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+    halDisplay = mDevice->GetDisplay(hwcDisplay);
+
+    if (!halDisplay) { [[unlikely]]
+        return HWC2_ERROR_BAD_DISPLAY;
+    }
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getHalLayer(int64_t display, int64_t layer, HwcLayer*& halLayer) {
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    hwc2_layer_t hwcLayer;
+    a2h::translate(layer, hwcLayer);
+    halLayer = halDisplay->get_layer(hwcLayer);
+    if (!halLayer) { [[unlikely]]
+        return HWC2_ERROR_BAD_LAYER;
+    }
+
+    return HWC2_ERROR_NONE;
+}
+
+bool HalImpl::hasCapability(Capability cap) {
+    return mCaps.find(cap) != mCaps.end();
+}
+
+void HalImpl::getCapabilities(std::vector<Capability>* caps) {
+    caps->clear();
+    caps->insert(caps->begin(), mCaps.begin(), mCaps.end());
+}
+
+void HalImpl::dumpDebugInfo(std::string* output) {
+    if (output == nullptr) return;
+/* FIXME:
+    String8 result;
+    mDevice->dump(result);
+
+    output->resize(result.size());
+    output->assign(result.c_str());
+*/
+}
+
+void HalImpl::registerEventCallback(EventCallback* callback) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    mEventCallback = callback;
+
+    mDevice->RegisterCallback(HWC2_CALLBACK_HOTPLUG, this,
+                              reinterpret_cast<hwc2_function_pointer_t>(hook::hotplug));
+    mDevice->RegisterCallback(HWC2_CALLBACK_REFRESH, this,
+                              reinterpret_cast<hwc2_function_pointer_t>(hook::refresh));
+    mDevice->RegisterCallback(HWC2_CALLBACK_VSYNC_2_4, this,
+                     reinterpret_cast<hwc2_function_pointer_t>(hook::vsync));
+    mDevice->RegisterCallback(HWC2_CALLBACK_VSYNC_PERIOD_TIMING_CHANGED, this,
+                     reinterpret_cast<hwc2_function_pointer_t>(hook::vsyncPeriodTimingChanged));
+    mDevice->RegisterCallback(HWC2_CALLBACK_SEAMLESS_POSSIBLE, this,
+                     reinterpret_cast<hwc2_function_pointer_t>(hook::seamlessPossible));
+
+    // register HWC3 Callback
+    mDevice->RegisterHwc3Callback(IComposerCallback::TRANSACTION_onVsyncIdle, this,
+                                  reinterpret_cast<hwc2_function_pointer_t>(hook::vsyncIdle));
+}
+
+void HalImpl::unregisterEventCallback() {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    mDevice->RegisterCallback(HWC2_CALLBACK_HOTPLUG, this, nullptr);
+    mDevice->RegisterCallback(HWC2_CALLBACK_REFRESH, this, nullptr);
+    mDevice->RegisterCallback(HWC2_CALLBACK_VSYNC_2_4, this, nullptr);
+    mDevice->RegisterCallback(HWC2_CALLBACK_VSYNC_PERIOD_TIMING_CHANGED, this, nullptr);
+    mDevice->RegisterCallback(HWC2_CALLBACK_SEAMLESS_POSSIBLE, this, nullptr);
+
+    // unregister HWC3 Callback
+    mDevice->RegisterHwc3Callback(IComposerCallback::TRANSACTION_onVsyncIdle, this, nullptr);
+
+    mEventCallback = nullptr;
+}
+
+int32_t HalImpl::acceptDisplayChanges(int64_t display) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->AcceptDisplayChanges();
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::createLayer(int64_t display, int64_t* outLayer) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_layer_t hwcLayer = 0;
+
+    hwcError = halDisplay->CreateLayer(&hwcLayer);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcLayer, *outLayer);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::destroyLayer(int64_t display, int64_t layer) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->DestroyLayer(static_cast<hwc2_layer_t>(layer));
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::createVirtualDisplay(uint32_t width, uint32_t height, AidlPixelFormat format,
+                                      VirtualDisplay* outDisplay) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcFormat;
+    a2h::translate(format, hwcFormat);
+    hwc2_display_t hwcDisplay = 0;
+
+    hwcError = mDevice->CreateVirtualDisplay(width, height, &hwcFormat, &hwcDisplay);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcDisplay, outDisplay->display);
+    h2a::translate(hwcFormat, outDisplay->format);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::destroyVirtualDisplay(int64_t display) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_display_t hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    hwcError = mDevice->DestroyVirtualDisplay(hwcDisplay);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::getActiveConfig(int64_t display, int32_t* outConfig) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_config_t hwcConfig;
+
+    hwcError = halDisplay->GetActiveConfig(&hwcConfig);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcConfig, *outConfig);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getColorModes(int64_t display, std::vector<ColorMode>* outModes) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetColorModes(&count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<int32_t> hwcModes(count);
+
+    hwcError = halDisplay->GetColorModes(&count, hwcModes.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcModes, *outModes);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDataspaceSaturationMatrix([[maybe_unused]] common::Dataspace dataspace,
+                                              std::vector<float>* matrix) {
+    // HWC does not support dataspace saturation matrix, return unit matrix.
+    std::vector<float> unitMatrix = {
+        1.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 1.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 1.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 1.0f,
+    };
+
+    *matrix = std::move(unitMatrix);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayAttribute(int64_t display, int32_t config,
+                                     DisplayAttribute attribute, int32_t* outValue) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    hwc2_config_t hwcConfig;
+    int32_t hwcAttr;
+    a2h::translate(config, hwcConfig);
+    a2h::translate(attribute, hwcAttr);
+
+    auto err = halDisplay->GetDisplayAttribute(hwcConfig, hwcAttr, outValue);
+    if (err != HWC2::Error::None && *outValue == -1) {
+        return HWC2_ERROR_BAD_PARAMETER;
+    }
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayBrightnessSupport(int64_t display, bool& outSupport) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->GetDisplayBrightnessSupport(&outSupport);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::getDisplayCapabilities(int64_t display,
+                                        std::vector<DisplayCapability>* caps) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetDisplayCapabilities(&count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<uint32_t> hwcCaps(count);
+    hwcError = halDisplay->GetDisplayCapabilities(&count, hwcCaps.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcCaps, *caps);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetDisplayConfigs(&count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<hwc2_config_t> hwcConfigs(count);
+    hwcError = halDisplay->GetDisplayConfigs(&count, hwcConfigs.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcConfigs, *configs);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayConnectionType(int64_t display, DisplayConnectionType* outType) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t hwcType = HWC2_DISPLAY_CONNECTION_TYPE_INTERNAL;
+
+    hwcError = halDisplay->GetDisplayConnectionType(&hwcType);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcType, *outType);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayIdentificationData(int64_t display, DisplayIdentification *id) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint8_t port;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetDisplayIdentificationData(&port, &count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    id->data.resize(count);
+    hwcError = halDisplay->GetDisplayIdentificationData(&port, &count, id->data.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(port, id->port);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayName(int64_t display, std::string* outName) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetDisplayName(&count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    outName->resize(count);
+    hwcError = halDisplay->GetDisplayName(&count, outName->data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayVsyncPeriod(int64_t display, int32_t* outVsyncPeriod) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_vsync_period_t hwcVsyncPeriod;
+
+    hwcError = halDisplay->GetDisplayVsyncPeriod(&hwcVsyncPeriod);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcVsyncPeriod, *outVsyncPeriod);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayedContentSample([[maybe_unused]] int64_t display,
+                                           [[maybe_unused]] int64_t maxFrames,
+                                           [[maybe_unused]] int64_t timestamp,
+                                           [[maybe_unused]] DisplayContentSample* samples) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::getDisplayedContentSamplingAttributes(
+        [[maybe_unused]] int64_t display,
+        [[maybe_unused]] DisplayContentSamplingAttributes* attrs) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::getDisplayPhysicalOrientation(int64_t display,
+                                               common::Transform* orientation) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    HwcMountOrientation hwcOrientation;
+
+    hwcError = halDisplay->GetMountOrientation(&hwcOrientation);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcOrientation, *orientation);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDozeSupport(int64_t display, bool& support) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcSupport;
+
+    hwcError = halDisplay->GetDozeSupport(&hwcSupport);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcSupport, support);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getHdrCapabilities(int64_t display, HdrCapabilities* caps) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetHdrCapabilities(&count, nullptr, &caps->maxLuminance,
+                                              &caps->maxAverageLuminance,
+                                              &caps->minLuminance);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<int32_t> hwcHdrTypes(count);
+    hwcError = halDisplay->GetHdrCapabilities(&count, hwcHdrTypes.data(),
+                                              &caps->maxLuminance,
+                                              &caps->maxAverageLuminance,
+                                              &caps->minLuminance);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcHdrTypes, caps->types);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getMaxVirtualDisplayCount(int32_t* count) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+    uint32_t hwcCount = mDevice->GetMaxVirtualDisplayCount();
+    h2a::translate(hwcCount, *count);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getPerFrameMetadataKeys(int64_t display,
+                                         std::vector<PerFrameMetadataKey>* keys) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    uint32_t error;
+    HWC2::Error hwcError;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetPerFrameMetadataKeys(&count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<int32_t> hwcKeys(count);
+    hwcError = halDisplay->GetPerFrameMetadataKeys(&count, hwcKeys.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcKeys, *keys);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getReadbackBufferAttributes(int64_t display,
+                                             ReadbackBufferAttributes* attrs) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t format = -1;
+    int32_t dataspace = -1;
+
+    hwcError = halDisplay->GetReadbackBufferAttributes(&format, &dataspace);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(format, attrs->format);
+    h2a::translate(dataspace, attrs->dataspace);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getReadbackBufferFence(int64_t display,
+                                        ndk::ScopedFileDescriptor* acquireFence) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t fd = -1;
+
+    hwcError = halDisplay->GetReadbackBufferFence(&fd);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(fd, *acquireFence);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getRenderIntents(int64_t display, ColorMode mode,
+                                  std::vector<RenderIntent>* intents) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcMode;
+    uint32_t count = 0;
+
+    a2h::translate(mode, hwcMode);
+    hwcError = halDisplay->GetRenderIntents(hwcMode, &count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<int32_t> hwcIntents(count);
+    hwcError = halDisplay->GetRenderIntents(hwcMode, &count, hwcIntents.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcIntents, *intents);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getSupportedContentTypes(int64_t display, std::vector<ContentType>* types) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    uint32_t count = 0;
+
+    hwcError = halDisplay->GetSupportedContentTypes(&count, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<uint32_t> hwcTypes(count);
+    hwcError = halDisplay->GetSupportedContentTypes(&count, hwcTypes.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcTypes, *types);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::presentDisplay(int64_t display, ndk::ScopedFileDescriptor& fence,
+                       std::vector<int64_t>* outLayers,
+                       std::vector<ndk::ScopedFileDescriptor>* outReleaseFences) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    int32_t error;
+    HWC2::Error hwcError;
+    int32_t hwcFence = -1;
+
+    hwcError = halDisplay->PresentDisplay(&hwcFence);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+    h2a::translate(hwcFence, fence);
+
+    uint32_t count = 0;
+    hwcError = halDisplay->GetReleaseFences(&count, nullptr, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<hwc2_layer_t> hwcLayers(count);
+    std::vector<int32_t> hwcFences(count);
+    hwcError = halDisplay->GetReleaseFences(&count, hwcLayers.data(), hwcFences.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcLayers, *outLayers);
+    h2a::translate(hwcFences, *outReleaseFences);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setActiveConfig(int64_t display, int32_t config) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_config_t hwcConfig;
+    a2h::translate(config, hwcConfig);
+
+    hwcError = halDisplay->SetActiveConfig(hwcConfig);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setActiveConfigWithConstraints(
+            int64_t display, int32_t config,
+            const VsyncPeriodChangeConstraints& vsyncPeriodChangeConstraints,
+            VsyncPeriodChangeTimeline* timeline) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_config_t hwcConfig;
+    hwc_vsync_period_change_constraints_t hwcConstraints;
+    hwc_vsync_period_change_timeline_t hwcTimeline;
+
+    a2h::translate(config, hwcConfig);
+    a2h::translate(vsyncPeriodChangeConstraints, hwcConstraints);
+    hwcError = halDisplay->SetActiveConfigWithConstraints(hwcConfig, &hwcConstraints, &hwcTimeline);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcTimeline, *timeline);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setBootDisplayConfig(int64_t display, int32_t config) {
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->SetBootDisplayConfig(config);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::clearBootDisplayConfig(int64_t display) {
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->ClearBootDisplayConfig();
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::getPreferredBootDisplayConfig(int64_t display, int32_t* config) {
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->GetPreferredBootDisplayConfig(config);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setAutoLowLatencyMode(int64_t display, bool on) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->SetAutoLowLatencyMode(on);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setClientTarget(int64_t display, buffer_handle_t target,
+                                 const ndk::ScopedFileDescriptor& fence,
+                                 common::Dataspace dataspace,
+                                 const std::vector<common::Rect>& damage) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    int32_t hwcFence;
+    int32_t hwcDataspace;
+    std::vector<hwc_rect_t> hwcDamage;
+
+    a2h::translate(fence, hwcFence);
+    a2h::translate(dataspace, hwcDataspace);
+    a2h::translate(damage, hwcDamage);
+    hwc_region_t region = { hwcDamage.size(), hwcDamage.data() };
+
+    hwcError = halDisplay->SetClientTarget(target, hwcFence, hwcDataspace, region);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setColorMode(int64_t display, ColorMode mode, RenderIntent intent) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcMode;
+    int32_t hwcIntent;
+
+    a2h::translate(mode, hwcMode);
+    a2h::translate(intent, hwcIntent);
+    hwcError = halDisplay->SetColorModeWithIntent(hwcMode, hwcIntent);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setColorTransform(int64_t display, const std::vector<float>& matrix) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    // clang-format off
+    constexpr std::array<float, 16> kIdentity = {
+        1.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 1.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 1.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 1.0f,
+    };
+    // clang-format on
+    const bool isIdentity = (std::equal(matrix.begin(), matrix.end(), kIdentity.begin()));
+    const common::ColorTransform hint = isIdentity ? common::ColorTransform::IDENTITY
+                                                   : common::ColorTransform::ARBITRARY_MATRIX;
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcHint;
+
+    a2h::translate(hint, hwcHint);
+    hwcError = halDisplay->SetColorTransform(matrix.data(), hwcHint);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setContentType(int64_t display, ContentType contentType) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t type;
+
+    a2h::translate(contentType, type);
+    hwcError = halDisplay->SetContentType(type);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setDisplayBrightness(int64_t display, float brightness) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->SetDisplayBrightness(brightness);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setDisplayedContentSamplingEnabled(
+        [[maybe_unused]] int64_t display,
+        [[maybe_unused]] bool enable,
+        [[maybe_unused]] FormatColorComponent componentMask,
+        [[maybe_unused]] int64_t maxFrames) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::setLayerBlendMode(int64_t display, int64_t layer, common::BlendMode mode) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcMode;
+
+    a2h::translate(mode, hwcMode);
+    hwcError = halLayer->SetLayerBlendMode(hwcMode);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerBuffer(int64_t display, int64_t layer, buffer_handle_t buffer,
+                                const ndk::ScopedFileDescriptor& acquireFence) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcFd;
+
+    a2h::translate(acquireFence, hwcFd);
+    hwcError = halLayer->SetLayerBuffer(buffer, hwcFd);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerColor(int64_t display, int64_t layer, Color color) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc_color_t hwcColor;
+
+    a2h::translate(color, hwcColor);
+    hwcError = halLayer->SetLayerColor(hwcColor);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerColorTransform(int64_t display, int64_t layer,
+                                        const std::vector<float>& matrix) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halLayer->SetLayerColorTransform(matrix.data());
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerCompositionType(int64_t display, int64_t layer, Composition type) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcType;
+
+    a2h::translate(type, hwcType);
+    hwcError = halLayer->SetLayerCompositionType(hwcType);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerCursorPosition(int64_t display, int64_t layer, int32_t x, int32_t y) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halLayer->SetCursorPosition(x, y);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerDataspace(int64_t display, int64_t layer, common::Dataspace dataspace) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcDataspace;
+
+    a2h::translate(dataspace, hwcDataspace);
+    hwcError = halLayer->SetLayerDataspace(hwcDataspace);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerDisplayFrame(int64_t display, int64_t layer, const common::Rect& frame) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc_rect_t hwcFrame;
+
+    a2h::translate(frame, hwcFrame);
+    hwcError = halLayer->SetLayerDisplayFrame(hwcFrame);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerPerFrameMetadata(int64_t display, int64_t layer,
+                           const std::vector<std::optional<PerFrameMetadata>>& metadata) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    uint32_t count = metadata.size();
+    std::vector<int32_t> keys;
+    std::vector<float> values;
+
+    for (uint32_t ix = 0; ix < count; ++ix) {
+        if (metadata[ix]) {
+            int32_t key;
+            a2h::translate(metadata[ix]->key, key);
+            keys.push_back(key);
+            values.push_back(metadata[ix]->value);
+        }
+    }
+
+    int32_t error;
+    HWC2::Error hwcError;
+    hwcError = halLayer->SetLayerPerFrameMetadata(count, keys.data(), values.data());
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                           const std::vector<std::optional<PerFrameMetadataBlob>>& blobs) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    uint32_t count = blobs.size();
+    std::vector<int32_t> keys;
+    std::vector<uint32_t> sizes;
+    std::vector<uint8_t> values;
+
+    for (uint32_t ix = 0; ix < count; ++ix) {
+        if (blobs[ix]) {
+            int32_t key;
+            a2h::translate(blobs[ix]->key, key);
+            keys.push_back(key);
+            sizes.push_back(blobs[ix]->blob.size());
+            values.insert(values.end(), blobs[ix]->blob.begin(), blobs[ix]->blob.end());
+        }
+    }
+
+    int32_t error;
+    HWC2::Error hwcError;
+    hwcError =  halLayer->SetLayerPerFrameMetadataBlobs(count, keys.data(),
+                                                        sizes.data(),
+                                                        values.data());
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerPlaneAlpha(int64_t display, int64_t layer, float alpha) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halLayer->SetLayerPlaneAlpha(alpha);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerSidebandStream([[maybe_unused]] int64_t display,
+                                        [[maybe_unused]] int64_t layer,
+                                        [[maybe_unused]] buffer_handle_t stream) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halLayer->SetLayerSidebandStream(stream);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerSourceCrop(int64_t display, int64_t layer, const common::FRect& crop) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc_frect_t hwcCrop;
+
+    a2h::translate(crop, hwcCrop);
+    hwcError = halLayer->SetLayerSourceCrop(hwcCrop);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerSurfaceDamage(int64_t display, int64_t layer,
+                                  const std::vector<std::optional<common::Rect>>& damage) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    std::vector<hwc_rect_t> hwcDamage;
+    a2h::translate(damage, hwcDamage);
+    hwc_region_t region = { hwcDamage.size(), hwcDamage.data() };
+
+    hwcError = halLayer->SetLayerSurfaceDamage(region);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerTransform(int64_t display, int64_t layer, common::Transform transform) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcTransform;
+
+    a2h::translate(transform, hwcTransform);
+    hwcError = halLayer->SetLayerTransform(hwcTransform);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerVisibleRegion(int64_t display, int64_t layer,
+                               const std::vector<std::optional<common::Rect>>& visible) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    std::vector<hwc_rect_t> hwcVisible;
+    a2h::translate(visible, hwcVisible);
+    hwc_region_t region = { hwcVisible.size(), hwcVisible.data() };
+
+    hwcError = halLayer->SetLayerVisibleRegion(region);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerBrightness(int64_t display, int64_t layer, float brightness) {
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halLayer->SetLayerBrightness(brightness);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setLayerZOrder(int64_t display, int64_t layer, uint32_t z) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcLayer *halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halLayer->SetLayerZOrder(z);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setOutputBuffer(int64_t display, buffer_handle_t buffer,
+                                 const ndk::ScopedFileDescriptor& releaseFence) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    int32_t hwcFence;
+    a2h::translate(releaseFence, hwcFence);
+
+    auto err = halDisplay->SetOutputBuffer(buffer, hwcFence);
+    // unlike in setClientTarget, releaseFence is owned by us
+    if (err == HWC2::Error::None && hwcFence >= 0) {
+        close(hwcFence);
+    }
+
+    return static_cast<int32_t>(err);
+}
+
+int32_t HalImpl::setPowerMode(int64_t display, PowerMode mode) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    if (mode == PowerMode::ON_SUSPEND || mode == PowerMode::DOZE_SUSPEND) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    int32_t hwcMode;
+
+    a2h::translate(mode, hwcMode);
+    hwcError = halDisplay->SetPowerMode(hwcMode);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setReadbackBuffer(int64_t display, buffer_handle_t buffer,
+                                   const ndk::ScopedFileDescriptor& releaseFence) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    int32_t hwcFence;
+    a2h::translate(releaseFence, hwcFence);
+
+    int32_t error;
+    HWC2::Error hwcError;
+    hwcError =  halDisplay->SetReadbackBuffer(buffer, hwcFence);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setVsyncEnabled(int64_t display, bool enabled) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+    hwc2_vsync_t hwcEnable;
+
+    a2h::translate(enabled, hwcEnable);
+    hwcError = halDisplay->SetVsyncEnabled(hwcEnable);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::setIdleTimerEnabled(int64_t /* display */, int32_t /* timeout */) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::validateDisplay(int64_t display, std::vector<int64_t>* outChangedLayers,
+                                 std::vector<Composition>* outCompositionTypes,
+                                 uint32_t* outDisplayRequestMask,
+                                 std::vector<int64_t>* outRequestedLayers,
+                                 std::vector<int32_t>* outRequestMasks,
+                                 ClientTargetProperty* outClientTargetProperty,
+                                 DimmingStage* outDimmingStage) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    uint32_t typesCount = 0;
+    uint32_t reqsCount = 0;
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->ValidateDisplay(&typesCount, &reqsCount);
+    h2a::translate(hwcError, error);
+    if (error != HWC2_ERROR_NONE && error != HWC2_ERROR_HAS_CHANGES) {
+        return error;
+    }
+
+    hwcError = halDisplay->GetChangedCompositionTypes(&typesCount, nullptr, nullptr);
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    std::vector<hwc2_layer_t> hwcChangedLayers(typesCount);
+    std::vector<int32_t> hwcCompositionTypes(typesCount);
+    hwcError = halDisplay->GetChangedCompositionTypes(&typesCount, hwcChangedLayers.data(),
+                                                      hwcCompositionTypes.data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    int32_t displayReqs;
+    std::vector<hwc2_layer_t> hwcRequestedLayers(reqsCount);
+    outRequestMasks->resize(reqsCount);
+    hwcError = halDisplay->GetDisplayRequests(&displayReqs, &reqsCount,
+                                              hwcRequestedLayers.data(), outRequestMasks->data());
+    h2a::translate(hwcError, error);
+    RET_IF_ERR(error);
+
+    h2a::translate(hwcChangedLayers, *outChangedLayers);
+    h2a::translate(hwcCompositionTypes, *outCompositionTypes);
+    *outDisplayRequestMask = displayReqs;
+    h2a::translate(hwcRequestedLayers, *outRequestedLayers);
+
+    hwc_client_target_property hwcProperty;
+    HwcDimmingStage hwcDimmingStage;
+    hwcError = halDisplay->GetClientTargetProperty(&hwcProperty, &hwcDimmingStage);
+    if (hwcError == HWC2::Error::None) {
+        h2a::translate(hwcDimmingStage, *outDimmingStage);
+        h2a::translate(hwcProperty, *outClientTargetProperty);
+    } // else ignore this error
+
+    return HWC2_ERROR_NONE;
+}
+
+int HalImpl::setExpectedPresentTime(int64_t display,
+                                    const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    if (!expectedPresentTime.has_value())
+        return HWC2_ERROR_NONE;
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->SetExpectedPresentTime(expectedPresentTime->timestampNanos);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+int32_t HalImpl::getRCDLayerSupport(int64_t display, bool& outSupport) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    HWC2::Error hwcError;
+    int32_t error;
+
+    hwcError = halDisplay->GetRCDLayerSupport(&outSupport);
+    h2a::translate(hwcError, error);
+    return error;
+}
+
+int32_t HalImpl::setLayerBlockingRegion(
+        int64_t /* display */, int64_t /* layer */,
+        const std::vector<std::optional<common::Rect>>& /* blockingRegion */) {
+    /* FIXME
+    HwcLayer* halLayer;
+    RET_IF_ERR(getHalLayer(display, layer, halLayer));
+
+    std::vector<hwc_rect_t> halBlockingRegion;
+    a2h::translate(blockingRegion, halBlockingRegion);
+
+    return halLayer->SetLayerBlockingRegion(halBlockingRegion);
+    */
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::getDisplayIdleTimerSupport(int64_t display, bool& outSupport) {
+    const std::unique_lock lock(mDevice->GetResMan().GetMainLock());
+
+    HwcDisplay* halDisplay;
+    RET_IF_ERR(getHalDisplay(display, halDisplay));
+
+    int32_t error;
+    HWC2::Error hwcError;
+    hwcError = halDisplay->GetDisplayIdleTimerSupport(&outSupport);
+    h2a::translate(hwcError, error);
+
+    return error;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/impl/HalImpl.h b/hwc3/impl/HalImpl.h
new file mode 100644
index 0000000..7f87d34
--- /dev/null
+++ b/hwc3/impl/HalImpl.h
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <unordered_set>
+
+#include "include/IComposerHal.h"
+
+namespace android {
+
+class DrmHwcTwo;
+class HwcDisplay;
+class HwcLayer;
+
+} // namespace android
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// Forward aidl call to Exynos HWC
+class HalImpl : public IComposerHal {
+  public:
+    HalImpl(std::unique_ptr<::android::DrmHwcTwo> device);
+    virtual ~HalImpl() = default;
+
+    void getCapabilities(std::vector<Capability>* caps) override;
+    void dumpDebugInfo(std::string* output) override;
+    bool hasCapability(Capability cap) override;
+
+    void registerEventCallback(EventCallback* callback) override;
+    void unregisterEventCallback() override;
+
+    int32_t acceptDisplayChanges(int64_t display) override;
+    int32_t createLayer(int64_t display, int64_t* outLayer) override;
+    int32_t createVirtualDisplay(uint32_t width, uint32_t height, AidlPixelFormat format,
+                                 VirtualDisplay* outDisplay) override;
+    int32_t destroyLayer(int64_t display, int64_t layer) override;
+    int32_t destroyVirtualDisplay(int64_t display) override;
+    int32_t getActiveConfig(int64_t display, int32_t* outConfig) override;
+    int32_t getColorModes(int64_t display, std::vector<ColorMode>* outModes) override;
+
+    int32_t getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                         std::vector<float>* matrix) override;
+    int32_t getDisplayAttribute(int64_t display, int32_t config, DisplayAttribute attribute,
+                                int32_t* outValue) override;
+    int32_t getDisplayBrightnessSupport(int64_t display, bool& outSupport) override;
+    int32_t getDisplayCapabilities(int64_t display, std::vector<DisplayCapability>* caps) override;
+    int32_t getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) override;
+    int32_t getDisplayConnectionType(int64_t display, DisplayConnectionType* outType) override;
+    int32_t getDisplayIdentificationData(int64_t display, DisplayIdentification* id) override;
+    int32_t getDisplayName(int64_t display, std::string* outName) override;
+    int32_t getDisplayVsyncPeriod(int64_t display, int32_t* outVsyncPeriod) override;
+    int32_t getDisplayedContentSample(int64_t display, int64_t maxFrames, int64_t timestamp,
+                                      DisplayContentSample* samples) override;
+    int32_t getDisplayedContentSamplingAttributes(int64_t display,
+                                                  DisplayContentSamplingAttributes* attrs) override;
+    int32_t getDisplayPhysicalOrientation(int64_t display, common::Transform* orientation) override;
+    int32_t getDozeSupport(int64_t display, bool& outSupport) override;
+    int32_t getHdrCapabilities(int64_t display, HdrCapabilities* caps) override;
+    int32_t getMaxVirtualDisplayCount(int32_t* count) override;
+    int32_t getPerFrameMetadataKeys(int64_t display,
+                                    std::vector<PerFrameMetadataKey>* keys) override;
+
+    int32_t getReadbackBufferAttributes(int64_t display, ReadbackBufferAttributes* attrs) override;
+    int32_t getReadbackBufferFence(int64_t display,
+                                   ndk::ScopedFileDescriptor* acquireFence) override;
+    int32_t getRenderIntents(int64_t display, ColorMode mode,
+                             std::vector<RenderIntent>* intents) override;
+    int32_t getSupportedContentTypes(int64_t display, std::vector<ContentType>* types) override;
+    int32_t presentDisplay(int64_t display, ndk::ScopedFileDescriptor& fence,
+                           std::vector<int64_t>* outLayers,
+                           std::vector<ndk::ScopedFileDescriptor>* outReleaseFences) override;
+    int32_t setActiveConfig(int64_t display, int32_t config) override;
+    int32_t setActiveConfigWithConstraints(
+            int64_t display, int32_t config,
+            const VsyncPeriodChangeConstraints& vsyncPeriodChangeConstraints,
+            VsyncPeriodChangeTimeline* timeline) override;
+    int32_t setBootDisplayConfig(int64_t display, int32_t config) override;
+    int32_t clearBootDisplayConfig(int64_t display) override;
+    int32_t getPreferredBootDisplayConfig(int64_t display, int32_t* config) override;
+    int32_t setAutoLowLatencyMode(int64_t display, bool on) override;
+    int32_t setClientTarget(int64_t display, buffer_handle_t target,
+                            const ndk::ScopedFileDescriptor& fence, common::Dataspace dataspace,
+                            const std::vector<common::Rect>& damage) override;
+    int32_t setColorMode(int64_t display, ColorMode mode, RenderIntent intent) override;
+    int32_t setColorTransform(int64_t display, const std::vector<float>& matrix) override;
+    int32_t setContentType(int64_t display, ContentType contentType) override;
+    int32_t setDisplayBrightness(int64_t display, float brightness) override;
+    int32_t setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                               FormatColorComponent componentMask,
+                                               int64_t maxFrames) override;
+    int32_t setLayerBlendMode(int64_t display, int64_t layer, common::BlendMode mode) override;
+    int32_t setLayerBuffer(int64_t display, int64_t layer, buffer_handle_t buffer,
+                           const ndk::ScopedFileDescriptor& acquireFence) override;
+    int32_t setLayerColor(int64_t display, int64_t layer, Color color) override;
+    int32_t setLayerColorTransform(int64_t display, int64_t layer,
+                                   const std::vector<float>& matrix) override;
+    int32_t setLayerCompositionType(int64_t display, int64_t layer, Composition type) override;
+    int32_t setLayerCursorPosition(int64_t display, int64_t layer, int32_t x, int32_t y) override;
+    int32_t setLayerDataspace(int64_t display, int64_t layer, common::Dataspace dataspace) override;
+    int32_t setLayerDisplayFrame(int64_t display, int64_t layer,
+                                 const common::Rect& frame) override;
+    int32_t setLayerPerFrameMetadata(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadata>>& metadata) override;
+    int32_t setLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadataBlob>>& blobs) override;
+    int32_t setLayerPlaneAlpha(int64_t display, int64_t layer, float alpha) override;
+    int32_t setLayerSidebandStream(int64_t display, int64_t layer,
+                                   buffer_handle_t stream) override;
+    int32_t setLayerSourceCrop(int64_t display, int64_t layer, const common::FRect& crop) override;
+    int32_t setLayerSurfaceDamage(int64_t display, int64_t layer,
+                                  const std::vector<std::optional<common::Rect>>& damage) override;
+    int32_t setLayerTransform(int64_t display, int64_t layer, common::Transform transform) override;
+    int32_t setLayerVisibleRegion(int64_t display, int64_t layer,
+                          const std::vector<std::optional<common::Rect>>& visible) override;
+    int32_t setLayerBrightness(int64_t display, int64_t layer, float brightness) override;
+    int32_t setLayerZOrder(int64_t display, int64_t layer, uint32_t z) override;
+    int32_t setOutputBuffer(int64_t display, buffer_handle_t buffer,
+                            const ndk::ScopedFileDescriptor& releaseFence) override;
+    int32_t setPowerMode(int64_t display, PowerMode mode) override;
+    int32_t setReadbackBuffer(int64_t display, buffer_handle_t buffer,
+                              const ndk::ScopedFileDescriptor& releaseFence) override;
+    int32_t setVsyncEnabled(int64_t display, bool enabled) override;
+    int32_t getDisplayIdleTimerSupport(int64_t display, bool& outSupport) override;
+    int32_t setIdleTimerEnabled(int64_t display, int32_t timeout) override;
+    int32_t getRCDLayerSupport(int64_t display, bool& outSupport) override;
+    int32_t setLayerBlockingRegion(
+            int64_t display, int64_t layer,
+            const std::vector<std::optional<common::Rect>>& blockingRegion) override;
+    int32_t validateDisplay(int64_t display, std::vector<int64_t>* outChangedLayers,
+                            std::vector<Composition>* outCompositionTypes,
+                            uint32_t* outDisplayRequestMask,
+                            std::vector<int64_t>* outRequestedLayers,
+                            std::vector<int32_t>* outRequestMasks,
+                            ClientTargetProperty* outClientTargetProperty,
+                            DimmingStage* outDimmingStage) override;
+    int32_t setExpectedPresentTime(
+            int64_t display,
+            const std::optional<ClockMonotonicTimestamp> expectedPresentTime) override;
+
+    EventCallback* getEventCallback() { return mEventCallback; }
+
+private:
+    void initCaps();
+    int32_t getHalDisplay(int64_t display, ::android::HwcDisplay*& halDisplay);
+    int32_t getHalLayer(int64_t display, int64_t layer, ::android::HwcLayer*& halLayer);
+
+    std::unique_ptr<::android::DrmHwcTwo> mDevice;
+    EventCallback* mEventCallback;
+    std::unordered_set<Capability> mCaps;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/impl/ResourceManager.cpp b/hwc3/impl/ResourceManager.cpp
new file mode 100644
index 0000000..fb92165
--- /dev/null
+++ b/hwc3/impl/ResourceManager.cpp
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "hwc3-resource-manager"
+
+#include <aidlcommonsupport/NativeHandle.h>
+
+#include "ResourceManager.h"
+#include "TranslateHwcAidl.h"
+
+using android::hardware::graphics::composer::V2_1::Display;
+using android::hardware::graphics::composer::V2_1::Error;
+using android::hardware::graphics::composer::V2_1::Layer;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+std::unique_ptr<IResourceManager> IResourceManager::create() {
+    return std::make_unique<ResourceManager>();
+}
+
+std::unique_ptr<IBufferReleaser> ResourceManager::createReleaser(bool isBuffer) {
+    return std::make_unique<BufferReleaser>(isBuffer);
+}
+
+void ResourceManager::clear(RemoveDisplay removeDisplay) {
+    mResources->clear([removeDisplay](Display hwcDisplay, bool isVirtual,
+                                      const std::vector<Layer> hwcLayers) {
+        int64_t display;
+        std::vector<int64_t> layers;
+        h2a::translate(hwcDisplay, display);
+        h2a::translate(hwcLayers, layers);
+
+        removeDisplay(display, isVirtual, layers);
+    });
+}
+
+bool ResourceManager::hasDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    return mResources->hasDisplay(hwcDisplay);
+}
+
+int32_t ResourceManager::addPhysicalDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->addPhysicalDisplay(hwcDisplay);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+
+int32_t ResourceManager::addVirtualDisplay(int64_t display, uint32_t outputBufferCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->addVirtualDisplay(hwcDisplay, outputBufferCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::removeDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->removeDisplay(hwcDisplay);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::setDisplayClientTargetCacheSize(int64_t display,
+                                                         uint32_t clientTargetCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->setDisplayClientTargetCacheSize(hwcDisplay, clientTargetCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayClientTargetCacheSize(int64_t display, size_t* outCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->getDisplayClientTargetCacheSize(hwcDisplay, outCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayOutputBufferCacheSize(int64_t display, size_t* outCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->getDisplayOutputBufferCacheSize(hwcDisplay, outCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::addLayer(int64_t display, int64_t layer, uint32_t bufferCacheSize) {
+    Display hwcDisplay;
+    Layer hwcLayer;
+
+    a2h::translate(display, hwcDisplay);
+    a2h::translate(layer, hwcLayer);
+
+    Error hwcErr = mResources->addLayer(hwcDisplay, hwcLayer, bufferCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::removeLayer(int64_t display, int64_t layer) {
+    Display hwcDisplay;
+    Layer hwcLayer;
+
+    a2h::translate(display, hwcDisplay);
+    a2h::translate(layer, hwcLayer);
+    Error hwcErr = mResources->removeLayer(hwcDisplay, hwcLayer);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+void ResourceManager::setDisplayMustValidateState(int64_t display, bool mustValidate) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    mResources->setDisplayMustValidateState(hwcDisplay, mustValidate);
+}
+
+bool ResourceManager::mustValidateDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    return mResources->mustValidateDisplay(hwcDisplay);
+}
+
+int32_t ResourceManager::getDisplayReadbackBuffer(int64_t display, const buffer_handle_t handle,
+                                                  buffer_handle_t& outHandle,
+                                                  IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    // dynamic_cast is not available
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getDisplayReadbackBuffer(hwcDisplay, handle, &outHandle,
+                                                        br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayClientTarget(int64_t display, uint32_t slot, bool fromCache,
+                                                const buffer_handle_t handle,
+                                                buffer_handle_t& outHandle,
+                                                IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getDisplayClientTarget(hwcDisplay, slot, fromCache, handle,
+                                                      &outHandle, br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayOutputBuffer(int64_t display, uint32_t slot, bool fromCache,
+                                   const buffer_handle_t handle,
+                                   buffer_handle_t& outHandle,
+                                   IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getDisplayOutputBuffer(hwcDisplay, slot, fromCache, handle,
+                                                      &outHandle, br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getLayerBuffer(int64_t display, int64_t layer, uint32_t slot,
+                                        bool fromCache, const buffer_handle_t rawHandle,
+                                        buffer_handle_t& outBufferHandle,
+                                        IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Layer hwcLayer;
+    a2h::translate(layer, hwcLayer);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getLayerBuffer(hwcDisplay, hwcLayer, slot, fromCache,
+                                                rawHandle, &outBufferHandle,
+                                                br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getLayerSidebandStream(int64_t display, int64_t layer,
+                                                const buffer_handle_t rawHandle,
+                                                buffer_handle_t& outStreamHandle,
+                                                IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Layer hwcLayer;
+    a2h::translate(layer, hwcLayer);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getLayerSidebandStream(hwcDisplay, hwcLayer, rawHandle,
+                                                      &outStreamHandle, br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/impl/ResourceManager.h b/hwc3/impl/ResourceManager.h
new file mode 100644
index 0000000..97dcdfe
--- /dev/null
+++ b/hwc3/impl/ResourceManager.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <composer-resources/2.2/ComposerResources.h>
+
+#include "include/IResourceManager.h"
+
+using android::hardware::graphics::composer::V2_2::hal::ComposerResources;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// Wrapper of ComposerResources before there is an aidl version
+class BufferReleaser : public IBufferReleaser {
+  public:
+    BufferReleaser(bool isBuffer) : mReplacedHandle(isBuffer) {}
+    virtual ~BufferReleaser() = default;
+
+    ComposerResources::ReplacedHandle* getReplacedHandle() { return &mReplacedHandle; }
+
+  private:
+    // ReplacedHandle releases buffer at its destruction.
+    ComposerResources::ReplacedHandle mReplacedHandle;
+};
+
+class ResourceManager : public IResourceManager {
+  public:
+    virtual ~ResourceManager() = default;
+
+    std::unique_ptr<IBufferReleaser> createReleaser(bool isBuffer) override;
+    void clear(RemoveDisplay removeDisplay) override;
+    bool hasDisplay(int64_t display) override;
+    int32_t addPhysicalDisplay(int64_t display) override;
+    int32_t addVirtualDisplay(int64_t display, uint32_t outputBufferCacheSize) override;
+    int32_t removeDisplay(int64_t display) override;
+    int32_t setDisplayClientTargetCacheSize(int64_t display,
+                                            uint32_t clientTargetCacheSize) override;
+    int32_t getDisplayClientTargetCacheSize(int64_t display, size_t* outCacheSize) override;
+    int32_t getDisplayOutputBufferCacheSize(int64_t display, size_t* outCacheSize) override;
+    int32_t addLayer(int64_t display, int64_t layer, uint32_t bufferCacheSize) override;
+    int32_t removeLayer(int64_t display, int64_t layer) override;
+    void setDisplayMustValidateState(int64_t display, bool mustValidate) override;
+    bool mustValidateDisplay(int64_t display) override;
+    int32_t getDisplayReadbackBuffer(int64_t display, const buffer_handle_t handle,
+                                     buffer_handle_t& outHandle,
+                                     IBufferReleaser* bufReleaser) override;
+    int32_t getDisplayClientTarget(int64_t display, uint32_t slot, bool fromCache,
+                                   const buffer_handle_t handle, buffer_handle_t& outHandle,
+                                   IBufferReleaser* bufReleaser) override;
+    int32_t getDisplayOutputBuffer(int64_t display, uint32_t slot, bool fromCache,
+                                   const buffer_handle_t handle, buffer_handle_t& outHandle,
+                                   IBufferReleaser* bufReleaser) override;
+    int32_t getLayerBuffer(int64_t display, int64_t layer, uint32_t slot, bool fromCache,
+                           const buffer_handle_t rawHandle,
+                           buffer_handle_t& outBufferHandle,
+                           IBufferReleaser* bufReleaser) override;
+    int32_t getLayerSidebandStream(int64_t display, int64_t layer,
+                                   const buffer_handle_t rawHandle,
+                                   buffer_handle_t& outStreamHandle,
+                                   IBufferReleaser* bufReleaser) override;
+  private:
+    std::unique_ptr<ComposerResources> mResources = ComposerResources::create();
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/impl/TranslateHwcAidl.h b/hwc3/impl/TranslateHwcAidl.h
new file mode 100644
index 0000000..ee9aa15
--- /dev/null
+++ b/hwc3/impl/TranslateHwcAidl.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/logging.h>
+// hwc2 types
+#include <hardware/hwcomposer2.h>
+// new hwc3 types used by Hw2Display
+#include <hwc2_device/Hwc3Types.h>
+// aidl types
+#include "include/IComposerHal.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// hwc2 to aidl conversion
+namespace h2a {
+
+template <typename T, typename U>
+inline void translate(const T& in, U& out) {
+    out = static_cast<U>(in);
+}
+
+template <typename T, typename U>
+inline void translate(const std::vector<T>& in, std::vector<U>& out) {
+    out.clear();
+    for (auto const &t : in) {
+        U u;
+        translate(t, u);
+        out.emplace_back(std::move(u));
+    }
+}
+
+template<>
+inline void translate(const hwc_vsync_period_change_timeline_t& in,
+                      VsyncPeriodChangeTimeline& out) {
+    out.newVsyncAppliedTimeNanos = in.newVsyncAppliedTimeNanos;
+    out.refreshRequired = in.refreshRequired;
+    out.refreshTimeNanos = in.refreshTimeNanos;
+}
+
+template<>
+inline void translate(const int32_t& fd, ndk::ScopedFileDescriptor& sfd) {
+    // ownership of fd is transferred to sfd
+    sfd = ndk::ScopedFileDescriptor(fd);
+}
+
+template<>
+inline void translate(const hwc_client_target_property& in, ClientTargetProperty& out) {
+    translate(in.pixelFormat, out.pixelFormat);
+    translate(in.dataspace, out.dataspace);
+}
+
+template<>
+inline void translate(const HwcMountOrientation& in, common::Transform& out) {
+    switch (in) {
+    case HwcMountOrientation::ROT_0:
+        out = common::Transform::NONE;
+        break;
+
+    case HwcMountOrientation::ROT_90:
+        out = common::Transform::ROT_90;
+        break;
+
+    case HwcMountOrientation::ROT_180:
+        out = common::Transform::ROT_180;
+        break;
+
+    case HwcMountOrientation::ROT_270:
+        out = common::Transform::ROT_270;
+        break;
+
+    default:
+        LOG(WARNING) << "unrecoganized display orientation: " << static_cast<uint32_t>(in);
+        out = common::Transform::NONE;
+        break;
+    }
+}
+
+} // namespace h2a
+
+// aidl to hwc2 conversion
+namespace a2h {
+
+template <typename T, typename U>
+inline void translate(const T& in, U& out) {
+    out = static_cast<U>(in);
+}
+
+template <typename T, typename U>
+inline void translate(const std::vector<std::optional<T>>& in, std::vector<U>& out) {
+    out.clear();
+    for (auto const &t : in) {
+        U u;
+        if (t) {
+            translate(*t, u);
+            out.emplace_back(std::move(u));
+        }
+    }
+}
+
+template <typename T, typename U>
+inline void translate(const std::vector<T>& in, std::vector<U>& out) {
+    out.clear();
+    for (auto const &t : in) {
+        U u;
+        translate(t, u);
+        out.emplace_back(std::move(u));
+    }
+}
+
+template<>
+inline void translate(const common::Rect& in, hwc_rect_t& out) {
+     out.left = in.left;
+     out.top = in.top;
+     out.right =in.right;
+     out.bottom =in.bottom;
+}
+
+template<>
+inline void translate(const common::FRect& in, hwc_frect_t& out) {
+     out.left = in.left;
+     out.top = in.top;
+     out.right =in.right;
+     out.bottom =in.bottom;
+}
+
+template <>
+inline void translate(const VsyncPeriodChangeConstraints& in,
+                      hwc_vsync_period_change_constraints_t& out) {
+    out.desiredTimeNanos = in.desiredTimeNanos;
+    out.seamlessRequired = in.seamlessRequired;
+}
+
+template<>
+inline void translate(const ndk::ScopedFileDescriptor& in, int32_t& out) {
+    // it's not defined as const. drop the const to avoid dup
+    auto& sfd = const_cast<ndk::ScopedFileDescriptor&>(in);
+    // take the ownership
+    out = sfd.get();
+    *sfd.getR() = -1;
+}
+
+template<>
+inline void translate(const bool& in, hwc2_vsync_t& out) {
+    // HWC_VSYNC_DISABLE is 2
+    out = in ? HWC2_VSYNC_ENABLE : HWC2_VSYNC_DISABLE;
+}
+
+template<>
+inline void translate(const Color& in, hwc_color_t& out) {
+    const auto floatColorToUint8Clamped = [](float val) -> uint8_t {
+        const auto intVal = static_cast<uint64_t>(std::round(255.0f * val));
+        const auto minVal = static_cast<uint64_t>(0);
+        const auto maxVal = static_cast<uint64_t>(255);
+        return std::clamp(intVal, minVal, maxVal);
+    };
+
+    out.r = floatColorToUint8Clamped(in.r);
+    out.g = floatColorToUint8Clamped(in.g);
+    out.b = floatColorToUint8Clamped(in.b);
+    out.a = floatColorToUint8Clamped(in.a);
+}
+
+} // namespace a2h
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/include/IComposerHal.h b/hwc3/include/IComposerHal.h
new file mode 100644
index 0000000..612260b
--- /dev/null
+++ b/hwc3/include/IComposerHal.h
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+/**
+ * Idealy IComposerHal should use aidl NativeHandle not native_handle_t/buffer_handle_t.
+ * However current patten is the HWC lib does not own buffer resources (HWC lib
+ * does own the fences).
+ */
+#include <aidl/android/hardware/common/NativeHandle.h>
+#include <aidl/android/hardware/graphics/common/BlendMode.h>
+#include <aidl/android/hardware/graphics/common/ColorTransform.h>
+#include <aidl/android/hardware/graphics/common/Dataspace.h>
+#include <aidl/android/hardware/graphics/common/FRect.h>
+#include <aidl/android/hardware/graphics/common/PixelFormat.h>
+#include <aidl/android/hardware/graphics/common/Point.h>
+#include <aidl/android/hardware/graphics/common/Rect.h>
+#include <aidl/android/hardware/graphics/common/Transform.h>
+#include <aidl/android/hardware/graphics/composer3/Buffer.h>
+#include <aidl/android/hardware/graphics/composer3/Capability.h>
+#include <aidl/android/hardware/graphics/composer3/ChangedCompositionTypes.h>
+#include <aidl/android/hardware/graphics/composer3/ClientTarget.h>
+#include <aidl/android/hardware/graphics/composer3/ClientTargetProperty.h>
+#include <aidl/android/hardware/graphics/composer3/ClientTargetPropertyWithBrightness.h>
+#include <aidl/android/hardware/graphics/composer3/Color.h>
+#include <aidl/android/hardware/graphics/composer3/ColorMode.h>
+#include <aidl/android/hardware/graphics/composer3/CommandError.h>
+#include <aidl/android/hardware/graphics/composer3/CommandResultPayload.h>
+#include <aidl/android/hardware/graphics/composer3/Composition.h>
+#include <aidl/android/hardware/graphics/composer3/ContentType.h>
+#include <aidl/android/hardware/graphics/composer3/DimmingStage.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayAttribute.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayBrightness.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCapability.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCommand.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayConnectionType.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayContentSample.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayContentSamplingAttributes.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayIdentification.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayRequest.h>
+#include <aidl/android/hardware/graphics/composer3/FormatColorComponent.h>
+#include <aidl/android/hardware/graphics/composer3/HdrCapabilities.h>
+#include <aidl/android/hardware/graphics/composer3/LayerBrightness.h>
+#include <aidl/android/hardware/graphics/composer3/LayerCommand.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableBlendMode.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableComposition.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableDataspace.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableTransform.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadata.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataBlob.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataKey.h>
+#include <aidl/android/hardware/graphics/composer3/PlaneAlpha.h>
+#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
+#include <aidl/android/hardware/graphics/composer3/PresentFence.h>
+#include <aidl/android/hardware/graphics/composer3/PresentOrValidate.h>
+#include <aidl/android/hardware/graphics/composer3/ReadbackBufferAttributes.h>
+#include <aidl/android/hardware/graphics/composer3/ReleaseFences.h>
+#include <aidl/android/hardware/graphics/composer3/RenderIntent.h>
+#include <aidl/android/hardware/graphics/composer3/VirtualDisplay.h>
+#include <aidl/android/hardware/graphics/composer3/VsyncPeriodChangeConstraints.h>
+#include <aidl/android/hardware/graphics/composer3/VsyncPeriodChangeTimeline.h>
+#include <aidl/android/hardware/graphics/composer3/ZOrder.h>
+#include <cutils/native_handle.h>
+
+// avoid naming conflict
+using AidlPixelFormat = aidl::android::hardware::graphics::common::PixelFormat;
+using AidlNativeHandle = aidl::android::hardware::common::NativeHandle;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// Abstraction of ComposerHal. Returned error code is compatible with AIDL
+// IComposerClient interface.
+class IComposerHal {
+ public:
+    static std::unique_ptr<IComposerHal> create();
+    virtual ~IComposerHal() = default;
+
+    virtual void getCapabilities(std::vector<Capability>* caps) = 0;
+    virtual void dumpDebugInfo(std::string* output) = 0;
+    virtual bool hasCapability(Capability cap) = 0;
+
+    class EventCallback {
+      public:
+        virtual ~EventCallback() = default;
+        virtual void onHotplug(int64_t display, bool connected) = 0;
+        virtual void onRefresh(int64_t display) = 0;
+        virtual void onVsync(int64_t display, int64_t timestamp, int32_t vsyncPeriodNanos) = 0;
+        virtual void onVsyncPeriodTimingChanged(int64_t display,
+                                                const VsyncPeriodChangeTimeline& timeline) = 0;
+        virtual void onVsyncIdle(int64_t display) = 0;
+        virtual void onSeamlessPossible(int64_t display) = 0;
+    };
+    virtual void registerEventCallback(EventCallback* callback) = 0;
+    virtual void unregisterEventCallback() = 0;
+
+    virtual int32_t acceptDisplayChanges(int64_t display) = 0;
+    virtual int32_t createLayer(int64_t display, int64_t* outLayer) = 0;
+    virtual int32_t createVirtualDisplay(uint32_t width, uint32_t height, AidlPixelFormat format,
+                                         VirtualDisplay* outDisplay) = 0;
+    virtual int32_t destroyLayer(int64_t display, int64_t layer) = 0;
+    virtual int32_t destroyVirtualDisplay(int64_t display) = 0;
+    virtual int32_t getActiveConfig(int64_t display, int32_t* outConfig) = 0;
+    virtual int32_t getColorModes(int64_t display, std::vector<ColorMode>* outModes) = 0;
+    virtual int32_t getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                                 std::vector<float>* matrix) = 0;
+    virtual int32_t getDisplayAttribute(int64_t display, int32_t config,
+                                      DisplayAttribute attribute, int32_t* outValue) = 0;
+    virtual int32_t getDisplayBrightnessSupport(int64_t display, bool& outSupport) = 0;
+    virtual int32_t getDisplayIdleTimerSupport(int64_t display, bool& outSupport) = 0;
+
+    virtual int32_t getDisplayCapabilities(int64_t display,
+                                           std::vector<DisplayCapability>* caps) = 0;
+    virtual int32_t getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) = 0;
+    virtual int32_t getDisplayConnectionType(int64_t display, DisplayConnectionType* outType) = 0;
+    virtual int32_t getDisplayIdentificationData(int64_t display, DisplayIdentification *id) = 0;
+    virtual int32_t getDisplayName(int64_t display, std::string* outName) = 0;
+    virtual int32_t getDisplayVsyncPeriod(int64_t display, int32_t* outVsyncPeriod) = 0;
+    virtual int32_t getDisplayedContentSample(int64_t display, int64_t maxFrames,
+                                            int64_t timestamp, DisplayContentSample* samples) = 0;
+    virtual int32_t getDisplayedContentSamplingAttributes(
+            int64_t display, DisplayContentSamplingAttributes* attrs) = 0;
+    virtual int32_t getDisplayPhysicalOrientation(int64_t display,
+                                                  common::Transform* orientation) = 0;
+    virtual int32_t getDozeSupport(int64_t display, bool& outSupport) = 0;
+    virtual int32_t getHdrCapabilities(int64_t display, HdrCapabilities* caps) = 0;
+    virtual int32_t getMaxVirtualDisplayCount(int32_t* count) = 0;
+    virtual int32_t getPerFrameMetadataKeys(int64_t display,
+                                            std::vector<PerFrameMetadataKey>* keys) = 0;
+    virtual int32_t getReadbackBufferAttributes(int64_t display,
+                                                ReadbackBufferAttributes* attrs) = 0;
+    virtual int32_t getReadbackBufferFence(int64_t display,
+                                           ndk::ScopedFileDescriptor* aqcuireFence) = 0;
+    virtual int32_t getRenderIntents(int64_t display, ColorMode mode,
+                                     std::vector<RenderIntent>* intents) = 0;
+    virtual int32_t getSupportedContentTypes(int64_t display, std::vector<ContentType>* types) = 0;
+    virtual int32_t presentDisplay(int64_t display, ndk::ScopedFileDescriptor& fence,
+                                   std::vector<int64_t>* outLayers,
+                                   std::vector<ndk::ScopedFileDescriptor>* outReleaseFences) = 0;
+    virtual int32_t setActiveConfig(int64_t display, int32_t config) = 0;
+    virtual int32_t setActiveConfigWithConstraints(
+            int64_t display, int32_t config,
+            const VsyncPeriodChangeConstraints& vsyncPeriodChangeConstraints,
+            VsyncPeriodChangeTimeline* timeline) = 0;
+    virtual int32_t setBootDisplayConfig(int64_t display, int32_t config) = 0;
+    virtual int32_t clearBootDisplayConfig(int64_t display) = 0;
+    virtual int32_t getPreferredBootDisplayConfig(int64_t display, int32_t* config) = 0;
+    virtual int32_t setAutoLowLatencyMode(int64_t display, bool on) = 0;
+    virtual int32_t setClientTarget(int64_t display, buffer_handle_t target,
+                                    const ndk::ScopedFileDescriptor& fence,
+                                    common::Dataspace dataspace,
+                                    const std::vector<common::Rect>& damage) = 0; // cmd
+    virtual int32_t setColorMode(int64_t display, ColorMode mode, RenderIntent intent) = 0;
+    virtual int32_t setColorTransform(int64_t display, const std::vector<float>& matrix) = 0; // cmd
+    virtual int32_t setContentType(int64_t display, ContentType contentType) = 0;
+    virtual int32_t setDisplayBrightness(int64_t display, float brightness) = 0;
+    virtual int32_t setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                                       FormatColorComponent componentMask,
+                                                       int64_t maxFrames) = 0;
+    virtual int32_t setLayerBlendMode(int64_t display, int64_t layer, common::BlendMode mode) = 0;
+    virtual int32_t setLayerBuffer(int64_t display, int64_t layer, buffer_handle_t buffer,
+                                   const ndk::ScopedFileDescriptor& acquireFence) = 0;
+    virtual int32_t setLayerColor(int64_t display, int64_t layer, Color color) = 0;
+    virtual int32_t setLayerColorTransform(int64_t display, int64_t layer,
+                                           const std::vector<float>& matrix) = 0;
+    virtual int32_t setLayerCompositionType(int64_t display, int64_t layer, Composition type) = 0;
+    virtual int32_t setLayerCursorPosition(int64_t display, int64_t layer, int32_t x,
+                                           int32_t y) = 0;
+    virtual int32_t setLayerDataspace(int64_t display, int64_t layer,
+                                      common::Dataspace dataspace) = 0;
+    virtual int32_t setLayerDisplayFrame(int64_t display, int64_t layer,
+                                         const common::Rect& frame) = 0;
+    virtual int32_t setLayerPerFrameMetadata(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadata>>& metadata) = 0;
+    virtual int32_t setLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadataBlob>>& blobs) = 0;
+    virtual int32_t setLayerPlaneAlpha(int64_t display, int64_t layer, float alpha) = 0;
+    virtual int32_t setLayerSidebandStream(int64_t display, int64_t layer,
+                                           buffer_handle_t stream) = 0;
+    virtual int32_t setLayerSourceCrop(int64_t display, int64_t layer,
+                                       const common::FRect& crop) = 0;
+    virtual int32_t setLayerSurfaceDamage(int64_t display, int64_t layer,
+                        const std::vector<std::optional<common::Rect>>& damage) = 0;
+    virtual int32_t setLayerTransform(int64_t display, int64_t layer,
+                                      common::Transform transform) = 0;
+    virtual int32_t setLayerVisibleRegion(int64_t display, int64_t layer,
+                                 const std::vector<std::optional<common::Rect>>& visible) = 0;
+    virtual int32_t setLayerBrightness(int64_t display, int64_t layer, float brightness) = 0;
+    virtual int32_t setLayerZOrder(int64_t display, int64_t layer, uint32_t z) = 0;
+    virtual int32_t setOutputBuffer(int64_t display, buffer_handle_t buffer,
+                                    const ndk::ScopedFileDescriptor& releaseFence) = 0;
+    virtual int32_t setPowerMode(int64_t display, PowerMode mode) = 0;
+    virtual int32_t setReadbackBuffer(int64_t display, buffer_handle_t buffer,
+                                      const ndk::ScopedFileDescriptor& releaseFence) = 0;
+    virtual int32_t setVsyncEnabled(int64_t display, bool enabled) = 0;
+    virtual int32_t validateDisplay(int64_t display, std::vector<int64_t>* outChangedLayers,
+                                    std::vector<Composition>* outCompositionTypes,
+                                    uint32_t* outDisplayRequestMask,
+                                    std::vector<int64_t>* outRequestedLayers,
+                                    std::vector<int32_t>* outRequestMasks,
+                                    ClientTargetProperty* outClientTargetProperty,
+                                    DimmingStage* outDimmingStage) = 0;
+    virtual int32_t setExpectedPresentTime(
+            int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) = 0;
+    virtual int32_t setIdleTimerEnabled(int64_t display, int32_t timeout) = 0;
+    virtual int32_t getRCDLayerSupport(int64_t display, bool& outSupport) = 0;
+    virtual int32_t setLayerBlockingRegion(
+            int64_t display, int64_t layer,
+            const std::vector<std::optional<common::Rect>>& blockingRegion) = 0;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::detail
diff --git a/hwc3/include/IResourceManager.h b/hwc3/include/IResourceManager.h
new file mode 100644
index 0000000..7def129
--- /dev/null
+++ b/hwc3/include/IResourceManager.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <aidlcommonsupport/NativeHandle.h>
+
+using AidlNativeHandle = aidl::android::hardware::common::NativeHandle;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+/// Some IResourceManager functions return a replaced buffer and that buffer should be
+// released later (at the time of IBufferReleaser object destruction)
+class IBufferReleaser {
+ public:
+    virtual ~IBufferReleaser() = default;
+};
+
+class IResourceManager {
+public:
+    static std::unique_ptr<IResourceManager> create();
+    using RemoveDisplay = std::function<void(int64_t display, bool isVirtual,
+                                             const std::vector<int64_t>& layers)>;
+    virtual ~IResourceManager() = default;
+    virtual std::unique_ptr<IBufferReleaser> createReleaser(bool isBuffer) = 0;
+
+    virtual void clear(RemoveDisplay removeDisplay) = 0;
+    virtual bool hasDisplay(int64_t display) = 0;
+    virtual int32_t addPhysicalDisplay(int64_t display) = 0;
+    virtual int32_t addVirtualDisplay(int64_t display, uint32_t outputBufferCacheSize) = 0;
+    virtual int32_t removeDisplay(int64_t display) = 0;
+    virtual int32_t setDisplayClientTargetCacheSize(int64_t display,
+                                                    uint32_t clientTargetCacheSize) = 0;
+    virtual int32_t getDisplayClientTargetCacheSize(int64_t display, size_t* outCacheSize) = 0;
+    virtual int32_t getDisplayOutputBufferCacheSize(int64_t display, size_t* outCacheSize) = 0;
+    virtual int32_t addLayer(int64_t display, int64_t layer, uint32_t bufferCacheSize) = 0;
+    virtual int32_t removeLayer(int64_t display, int64_t layer) = 0;
+    virtual void setDisplayMustValidateState(int64_t display, bool mustValidate) = 0;
+    virtual bool mustValidateDisplay(int64_t display) = 0;
+    virtual int32_t getDisplayReadbackBuffer(int64_t display, const buffer_handle_t handle,
+                                             buffer_handle_t& outHandle,
+                                             IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getDisplayClientTarget(int64_t display, uint32_t slot, bool fromCache,
+                                           const buffer_handle_t handle,
+                                           buffer_handle_t& outHandle,
+                                           IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getDisplayOutputBuffer(int64_t display, uint32_t slot, bool fromCache,
+                                           const buffer_handle_t handle,
+                                           buffer_handle_t& outHandle,
+                                           IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getLayerBuffer(int64_t display, int64_t layer, uint32_t slot,
+                                   bool fromCache,
+                                   const buffer_handle_t rawHandle,
+                                   buffer_handle_t& outBufferHandle,
+                                   IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getLayerSidebandStream(int64_t display, int64_t layer,
+                                           const buffer_handle_t rawHandle,
+                                           buffer_handle_t& outStreamHandle,
+                                           IBufferReleaser* bufReleaser) = 0;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/hwc3/service.cpp b/hwc3/service.cpp
new file mode 100644
index 0000000..bebb742
--- /dev/null
+++ b/hwc3/service.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "hwc3-service"
+
+#include <android-base/logging.h>
+#include <android/binder_manager.h>
+#include <android/binder_process.h>
+#include <binder/ProcessState.h>
+#include <sched.h>
+
+#include "Composer.h"
+
+using aidl::android::hardware::graphics::composer3::impl::Composer;
+using aidl::android::hardware::graphics::composer3::impl::IComposerHal;
+
+using android::base::InitLogging;
+using android::base::StderrLogger;
+using android::sp;
+
+int main(int /*argc*/, char* argv[]) {
+    InitLogging(argv, android::base::LogdLogger(android::base::SYSTEM));
+    LOG(INFO) << "hwc3 starting up";
+
+    // same as SF main thread
+    struct sched_param param = {0};
+    param.sched_priority = 2;
+    if (sched_setscheduler(0, SCHED_FIFO | SCHED_RESET_ON_FORK, &param) != 0) {
+        LOG(ERROR) << "Couldn't set SCHED_FIFO: " << errno;
+    }
+
+    std::unique_ptr<IComposerHal> halImpl = IComposerHal::create();
+    CHECK(halImpl != nullptr);
+
+    std::shared_ptr<Composer> composer = ndk::SharedRefBase::make<Composer>(std::move(halImpl));
+    CHECK(composer != nullptr);
+
+    const std::string instance = std::string() + Composer::descriptor + "/default";
+    binder_status_t status =
+            AServiceManager_addService(composer->asBinder().get(), instance.c_str());
+    CHECK(status == STATUS_OK);
+
+    // Thread pool for vendor libbinder for internal vendor services
+    android::ProcessState::self()->setThreadPoolMaxThreadCount(2);
+    android::ProcessState::self()->startThreadPool();
+
+    // Thread pool for system libbinder (via libbinder_ndk) for aidl services
+    // IComposer and IDisplay
+    ABinderProcess_setThreadPoolMaxThreadCount(5);
+    ABinderProcess_startThreadPool();
+    ABinderProcess_joinThreadPool();
+
+    return EXIT_FAILURE;  // should not reach
+}
-- 
2.34.1

