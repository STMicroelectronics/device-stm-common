From 89b6d5b19cec76be03cadc972c9946ddbd5a23f2 Mon Sep 17 00:00:00 2001
From: frq09432 <nicolas.louboutin@st.com>
Date: Wed, 6 Nov 2019 08:52:27 +0100
Subject: [PATCH] Bypass ReliableSurface generating display freeze on low-end
 devices

Change-Id: Ic9e1bd311d2e29486084bbfdbf7b0de7b6510c0f
---
 libs/hwui/renderthread/CanvasContext.cpp | 21 ++++-----------------
 libs/hwui/renderthread/CanvasContext.h   |  2 +-
 2 files changed, 5 insertions(+), 18 deletions(-)

diff --git a/libs/hwui/renderthread/CanvasContext.cpp b/libs/hwui/renderthread/CanvasContext.cpp
index 9898a1c..ec456c2 100644
--- a/libs/hwui/renderthread/CanvasContext.cpp
+++ b/libs/hwui/renderthread/CanvasContext.cpp
@@ -147,8 +147,7 @@ void CanvasContext::setSurface(sp<Surface>&& surface) {
     ATRACE_CALL();
 
     if (surface) {
-        mNativeSurface = new ReliableSurface{std::move(surface)};
-        // TODO: Fix error handling & re-shorten timeout
+        mNativeSurface = std::move(surface);
         mNativeSurface->setDequeueTimeout(4000_ms);
     } else {
         mNativeSurface = nullptr;
@@ -353,19 +352,7 @@ void CanvasContext::prepareTree(TreeInfo& info, int64_t* uiFrameInfo, int64_t sy
         info.out.canDrawThisFrame = false;
     }
 
-    if (info.out.canDrawThisFrame) {
-        int err = mNativeSurface->reserveNext();
-        if (err != OK) {
-            mCurrentFrameInfo->addFlag(FrameInfoFlags::SkippedFrame);
-            info.out.canDrawThisFrame = false;
-            ALOGW("reserveNext failed, error = %d (%s)", err, strerror(-err));
-            if (err != TIMED_OUT) {
-                // A timed out surface can still recover, but assume others are permanently dead.
-                setSurface(nullptr);
-                return;
-            }
-        }
-    } else {
+    if (!info.out.canDrawThisFrame) {
         mCurrentFrameInfo->addFlag(FrameInfoFlags::SkippedFrame);
     }
 
@@ -532,7 +519,7 @@ void CanvasContext::doFrame() {
 }
 
 SkISize CanvasContext::getNextFrameSize() const {
-    ReliableSurface* surface = mNativeSurface.get();
+    Surface* surface = mNativeSurface.get();
     if (surface) {
         SkISize size;
         surface->query(NATIVE_WINDOW_WIDTH, &size.fWidth);
@@ -669,7 +656,7 @@ bool CanvasContext::surfaceRequiresRedraw() {
 
     int width = -1;
     int height = -1;
-    ReliableSurface* surface = mNativeSurface.get();
+    Surface* surface = mNativeSurface.get();
     surface->query(NATIVE_WINDOW_WIDTH, &width);
     surface->query(NATIVE_WINDOW_HEIGHT, &height);
 
diff --git a/libs/hwui/renderthread/CanvasContext.h b/libs/hwui/renderthread/CanvasContext.h
index 982c087..f63a5cb 100644
--- a/libs/hwui/renderthread/CanvasContext.h
+++ b/libs/hwui/renderthread/CanvasContext.h
@@ -220,7 +220,7 @@ private:
     EGLint mLastFrameHeight = 0;
 
     RenderThread& mRenderThread;
-    sp<ReliableSurface> mNativeSurface;
+    sp<Surface> mNativeSurface;
     // stopped indicates the CanvasContext will reject actual redraw operations,
     // and defer repaint until it is un-stopped
     bool mStopped = false;
-- 
2.7.4

