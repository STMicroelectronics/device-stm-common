From 906f97b83447379c8f1461825ca6e0f94a4540af Mon Sep 17 00:00:00 2001
From: Nicolas LOUBOUTIN <nicolas.louboutin@st.com>
Date: Thu, 13 Oct 2022 18:28:45 +0200
Subject: [PATCH] Integrate Vivante libdrm add-on (6.4.9)

Signed-off-by: Nicolas LOUBOUTIN <nicolas.louboutin@st.com>
Change-Id: I941144edc3603cd7e0255b4841dba9d62fac2021
---
 Makefile.sources             |   1 +
 include/drm/drm_fourcc.h     |   9 +
 include/drm/vivante_drm.h    | 176 +++++++++++
 meson.build                  |  14 +
 tests/vivante/meson.build    |  27 ++
 tests/vivante/viv_bo_test.c  | 142 +++++++++
 vivante/Android.bp           |  25 ++
 vivante/Android.sources.bp   |   7 +
 vivante/libdrm_vivante.pc.in |  11 +
 vivante/meson.build          |  56 ++++
 vivante/vivante-symbols.txt  |  23 ++
 vivante/vivante_bo.c         | 586 +++++++++++++++++++++++++++++++++++
 vivante/vivante_bo.h         |  84 +++++
 13 files changed, 1161 insertions(+)
 create mode 100644 include/drm/vivante_drm.h
 create mode 100644 tests/vivante/meson.build
 create mode 100644 tests/vivante/viv_bo_test.c
 create mode 100644 vivante/Android.bp
 create mode 100644 vivante/Android.sources.bp
 create mode 100644 vivante/libdrm_vivante.pc.in
 create mode 100644 vivante/meson.build
 create mode 100644 vivante/vivante-symbols.txt
 create mode 100644 vivante/vivante_bo.c
 create mode 100644 vivante/vivante_bo.h

diff --git a/Makefile.sources b/Makefile.sources
index 55290fe9..399adc14 100644
--- a/Makefile.sources
+++ b/Makefile.sources
@@ -34,6 +34,7 @@ LIBDRM_INCLUDE_H_FILES := \
 	include/drm/savage_drm.h \
 	include/drm/sis_drm.h \
 	include/drm/tegra_drm.h \
+	include/drm/vivante_drm.h \
 	include/drm/vc4_drm.h \
 	include/drm/via_drm.h \
 	include/drm/virtgpu_drm.h
diff --git a/include/drm/drm_fourcc.h b/include/drm/drm_fourcc.h
index 957c7be2..2ca3fe64 100644
--- a/include/drm/drm_fourcc.h
+++ b/include/drm/drm_fourcc.h
@@ -630,6 +630,15 @@ extern "C" {
  */
 #define DRM_FORMAT_MOD_VIVANTE_SPLIT_SUPER_TILED fourcc_mod_code(VIVANTE, 4)
 
+/*
+ * Vivante 64x64 super-tiling with compression layout
+ *
+ * This is a tiled layout using 64x64 pixel super-tiles, where each super-tile
+ * contains 8x4 groups of 2x4 tiles of 4x4 pixels each, all in row-major layout
+ * with compression.
+ */
+#define DRM_FORMAT_MOD_VIVANTE_SUPER_TILED_FC  fourcc_mod_code(VIVANTE, 5)
+
 /* NVIDIA frame buffer modifiers */
 
 /*
diff --git a/include/drm/vivante_drm.h b/include/drm/vivante_drm.h
new file mode 100644
index 00000000..05af1e16
--- /dev/null
+++ b/include/drm/vivante_drm.h
@@ -0,0 +1,176 @@
+/****************************************************************************
+*
+*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*
+*    The material in this file is confidential and contains trade secrets
+*    of Vivante Corporation. This is proprietary information owned by
+*    Vivante Corporation. No part of this work may be disclosed,
+*    reproduced, copied, transmitted, or used in any way for any purpose,
+*    without the express written permission of Vivante Corporation.
+*
+*****************************************************************************/
+
+
+#ifndef __VIVNATE_DRM_H__
+#define __VIVNATE_DRM_H__
+
+#ifdef __KERNEL__
+#include <uapi/drm/drm.h>
+#else
+#include <drm.h>
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* creation flag bits. */
+#define DRM_VIV_GEM_CONTIGUOUS      (1u << 0)
+#define DRM_VIV_GEM_CACHED          (1u << 1)
+#define DRM_VIV_GEM_SECURE          (1u << 2)
+#define DRM_VIV_GEM_CMA_LIMIT       (1u << 3)
+
+struct drm_viv_gem_create {
+    __u64 size;
+    __u32 flags;
+    __u32 handle;
+};
+
+struct drm_viv_gem_lock {
+    __u32 handle;
+    __u32 cacheable;
+    __u64 logical;
+};
+
+struct drm_viv_gem_unlock {
+    __u32 handle;
+};
+
+
+#define DRM_VIV_GEM_CLEAN_CACHE         0x01
+#define DRM_VIV_GEM_INVALIDATE_CACHE    0x02
+#define DRM_VIV_GEM_FLUSH_CACHE         0x03
+#define DRM_VIV_GEM_MEMORY_BARRIER      0x04
+
+struct drm_viv_gem_cache {
+    __u32 handle;
+    __u32 op;
+    __u64 logical;
+    __u64 bytes;
+};
+
+
+#define DRM_VIV_GEM_PARAM_POOL      0x00
+#define DRM_VIV_GEM_PARAM_SIZE      0x01
+
+struct drm_viv_gem_query {
+    __u32 handle;
+    __u32 param;
+    __u64 value;
+};
+
+
+struct drm_viv_gem_timestamp {
+    __u32 handle;
+    /* inc count, 0 for query current. */
+    __u32 inc;
+    /* output inc'ed timestamp. */
+    __u64 timestamp;
+};
+
+
+/* basic tiling mode. */
+#define DRM_VIV_GEM_TILING_LINEAR       0x01
+#define DRM_VIV_GEM_TILING_TILED        0x02
+#define DRM_VIV_GEM_TILING_SUPERTILED   0x04
+#define DRM_VIV_GEM_TILING_MINORTILED   0x08
+
+/* tiling mode modifiers. */
+#define DRM_VIV_GEM_TILING_SPLIT    0x10
+#define DRM_VIV_GEM_TILING_X_MAJOR  0x20
+#define DRM_VIV_GEM_TILING_Y_MAJOR  0x40
+#define DRM_VIV_GEM_TILING_SWAP     0x80
+
+/* ts mode. */
+#define DRM_VIV_GEM_TS_NONE         0x00
+#define DRM_VIV_GEM_TS_DISABLED     0x01
+#define DRM_VIV_GEM_TS_NORMAL       0x02
+#define DRM_VIV_GEM_TS_COMPRESSED   0x03
+
+/* ts cache mode. */
+#define DRM_VIV_GEM_TS_CACHE_MODE_64B     0x00
+#define DRM_VIV_GEM_TS_CACHE_MODE_128B    0x01
+#define DRM_VIV_GEM_TS_CACHE_MODE_256B    0x02
+
+struct drm_viv_gem_set_tiling {
+    __u32 handle;
+    __u32 tiling_mode;
+
+    __u32 ts_mode;
+    __u32 ts_cache_mode;
+    __u64 clear_value;
+};
+
+struct drm_viv_gem_get_tiling {
+    __u32 handle;
+    __u32 tiling_mode;
+
+    __u32 ts_mode;
+    __u32 ts_cache_mode;
+    __u64 clear_value;
+};
+
+
+struct drm_viv_gem_attach_aux {
+    __u32 handle;
+    __u32 ts_handle;
+};
+
+
+struct drm_viv_gem_ref_node {
+    __u32 handle;
+
+    /* output. */
+    __u32 node;
+    __u32 ts_node;
+};
+
+
+#define DRM_VIV_GEM_CREATE          0x00
+#define DRM_VIV_GEM_LOCK            0x01
+#define DRM_VIV_GEM_UNLOCK          0x02
+#define DRM_VIV_GEM_CACHE           0x03
+#define DRM_VIV_GEM_QUERY           0x04
+#define DRM_VIV_GEM_TIMESTAMP       0x05
+#define DRM_VIV_GEM_SET_TILING      0x06
+#define DRM_VIV_GEM_GET_TILING      0x07
+#define DRM_VIV_GEM_ATTACH_AUX      0x08
+#define DRM_VIV_GEM_REF_NODE        0x09
+#define DRM_VIV_NUM_IOCTLS          0x0A
+
+#define DRM_IOCTL_VIV_GEM_CREATE        DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_CREATE,     struct drm_viv_gem_create)
+#define DRM_IOCTL_VIV_GEM_LOCK          DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_LOCK,       struct drm_viv_gem_lock)
+#define DRM_IOCTL_VIV_GEM_UNLOCK        DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_UNLOCK,     struct drm_viv_gem_unlock)
+#define DRM_IOCTL_VIV_GEM_CACHE         DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_CACHE,      struct drm_viv_gem_cache)
+#define DRM_IOCTL_VIV_GEM_QUERY         DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_QUERY,      struct drm_viv_gem_query)
+#define DRM_IOCTL_VIV_GEM_TIMESTAMP     DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_TIMESTAMP,  struct drm_viv_gem_timestamp)
+#define DRM_IOCTL_VIV_GEM_SET_TILING    DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_SET_TILING, struct drm_viv_gem_set_tiling)
+#define DRM_IOCTL_VIV_GEM_GET_TILING    DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_GET_TILING, struct drm_viv_gem_get_tiling)
+#define DRM_IOCTL_VIV_GEM_ATTACH_AUX    DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_ATTACH_AUX, struct drm_viv_gem_attach_aux)
+#define DRM_IOCTL_VIV_GEM_REF_NODE      DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_REF_NODE,   struct drm_viv_gem_ref_node)
+
+#ifdef __KERNEL__
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+#define drm_gem_object_unreference_unlocked drm_gem_object_put
+#define drm_dev_unref drm_dev_put
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
+#define drm_gem_object_unreference_unlocked drm_gem_object_put_unlocked
+#define drm_dev_unref drm_dev_put
+#endif
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* __VIVNATE_DRM_H__ */
diff --git a/meson.build b/meson.build
index 5824da8a..ec015fbf 100644
--- a/meson.build
+++ b/meson.build
@@ -151,6 +151,15 @@ if _tegra == 'true'
   with_tegra = true
 endif
 
+with_vivante = false
+_vivante = get_option('vivante')
+if _vivante == 'true'
+  if not with_atomics
+    error('libdrm_vivante requires atomics.')
+  endif
+  with_vivante = true
+endif
+
 with_etnaviv = false
 _etnaviv = get_option('etnaviv')
 if _etnaviv == 'true'
@@ -350,6 +359,7 @@ install_headers(
   'include/drm/radeon_drm.h', 'include/drm/amdgpu_drm.h',
   'include/drm/savage_drm.h', 'include/drm/sis_drm.h',
   'include/drm/tegra_drm.h', 'include/drm/vc4_drm.h',
+  'include/drm/vivante_drm.h',
   'include/drm/via_drm.h', 'include/drm/virtgpu_drm.h',
   subdir : 'libdrm',
 )
@@ -392,6 +402,9 @@ endif
 if with_tegra
   subdir('tegra')
 endif
+if with_vivante
+  subdir('vivante')
+endif
 if with_vc4
   subdir('vc4')
 endif
@@ -417,6 +430,7 @@ message('  OMAP API       @0@'.format(with_omap))
 message('  EXYNOS API     @0@'.format(with_exynos))
 message('  Freedreno API  @0@ (kgsl: @1@)'.format(with_freedreno, with_freedreno_kgsl))
 message('  Tegra API      @0@'.format(with_tegra))
+message('  Vivante API    @0@'.format(with_vivante))
 message('  VC4 API        @0@'.format(with_vc4))
 message('  Etnaviv API    @0@'.format(with_etnaviv))
 message('')
diff --git a/tests/vivante/meson.build b/tests/vivante/meson.build
new file mode 100644
index 00000000..5d371df6
--- /dev/null
+++ b/tests/vivante/meson.build
@@ -0,0 +1,27 @@
+# Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+viv_bo_test = executable(
+  'viv_bo_test',
+  files('viv_bo_test.c'),
+  include_directories : [inc_root, inc_drm, include_directories('../../vivante')],
+  c_args : libdrm_c_args,
+  link_with : [libdrm, libdrm_vivante],
+)
diff --git a/tests/vivante/viv_bo_test.c b/tests/vivante/viv_bo_test.c
new file mode 100644
index 00000000..dd315005
--- /dev/null
+++ b/tests/vivante/viv_bo_test.c
@@ -0,0 +1,142 @@
+/****************************************************************************
+*
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
+*
+*    The material in this file is confidential and contains trade secrets
+*    of Vivante Corporation. This is proprietary information owned by
+*    Vivante Corporation. No part of this work may be disclosed,
+*    reproduced, copied, transmitted, or used in any way for any purpose,
+*    without the express written permission of Vivante Corporation.
+*
+*****************************************************************************/
+
+
+/*
+ * Copyright Â© 2015 Canonical Ltd. (Maarten Lankhorst)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <sys/ioctl.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <pthread.h>
+
+#include "xf86drm.h"
+#include "vivante_bo.h"
+
+static int import_fd = -1;
+
+static void *
+openclose(void *dev)
+{
+    struct drm_vivante *drm = dev;
+    struct drm_vivante_bo *bo;
+    int i;
+
+    for (i = 0; i < 100000; ++i) {
+        if (!drm_vivante_bo_import_from_fd(drm, import_fd, &bo))
+            drm_vivante_bo_destroy(bo);
+    }
+    return NULL;
+}
+
+int main(int argc, char *argv[])
+{
+    drmVersionPtr version;
+    const char *device = NULL;
+    int err, fd1, fd2;
+    struct drm_vivante *drm1, *drm2;
+    struct drm_vivante_bo *bo;
+    pthread_t t1, t2;
+
+    if (argc < 2) {
+        fd1 = drmOpenWithType("vivante", NULL, DRM_NODE_RENDER);
+        if (fd1 >= 0)
+            fd2 = drmOpenWithType("vivante", NULL, DRM_NODE_RENDER);
+    } else {
+        device = argv[1];
+
+        fd1 = open(device, O_RDWR);
+        if (fd1 >= 0)
+            fd2 = open(device, O_RDWR);
+        else
+            fd2 = fd1 = -errno;
+    }
+
+    if (fd1 < 0) {
+        fprintf(stderr, "Opening 1st vivante render node failed with %i\n", fd1);
+        return device ? -fd1 : 77;
+    }
+
+    if (fd2 < 0) {
+        fprintf(stderr, "Opening 2nd vivante render node failed with %i\n", -errno);
+        return errno;
+    }
+
+    version = drmGetVersion(fd1);
+    if (version) {
+        printf("Version: %d.%d.%d\n", version->version_major,
+               version->version_minor, version->version_patchlevel);
+        printf("  Name: %s\n", version->name);
+        printf("  Date: %s\n", version->date);
+        printf("  Description: %s\n", version->desc);
+
+        drmFreeVersion(version);
+    }
+
+    err = drm_vivante_create(fd1, &drm1);
+    if (!err)
+        err = drm_vivante_create(fd2, &drm2);
+    if (err < 0)
+        return 1;
+
+    err = drm_vivante_bo_create(drm2, 0, 1920*1080*4, &bo);
+    if (!err)
+        err = drm_vivante_bo_export_to_fd(bo, &import_fd);
+
+    if (!err) {
+        pthread_create(&t1, NULL, openclose, (void*)drm1);
+        pthread_create(&t2, NULL, openclose, (void*)drm1);
+    }
+
+    pthread_join(t1, NULL);
+    pthread_join(t2, NULL);
+
+    drm_vivante_bo_destroy(bo);
+
+    drm_vivante_close(drm2);
+    drm_vivante_close(drm1);
+    if (device) {
+        close(fd2);
+        close(fd1);
+    } else {
+        drmClose(fd2);
+        drmClose(fd1);
+    }
+
+    return 0;
+}
diff --git a/vivante/Android.bp b/vivante/Android.bp
new file mode 100644
index 00000000..b162bc6e
--- /dev/null
+++ b/vivante/Android.bp
@@ -0,0 +1,25 @@
+//#############################################################################
+//
+//    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+//
+//    The material in this file is confidential and contains trade secrets
+//    of Vivante Corporation. This is proprietary information owned by
+//    Vivante Corporation. No part of this work may be disclosed,
+//    reproduced, copied, transmitted, or used in any way for any purpose,
+//    without the express written permission of Vivante Corporation.
+//
+//#############################################################################
+
+build = ["Android.sources.bp"]
+
+cc_library_shared {
+    name: "libdrm_vivante",
+    defaults: [
+        "libdrm_defaults",
+        "libdrm_vivante_sources",
+    ],
+    vendor: true,
+    shared_libs: ["libdrm", "liblog"],
+
+    cflags: ["-Wno-unused-parameter"],
+}
diff --git a/vivante/Android.sources.bp b/vivante/Android.sources.bp
new file mode 100644
index 00000000..dfd6789b
--- /dev/null
+++ b/vivante/Android.sources.bp
@@ -0,0 +1,7 @@
+
+cc_defaults {
+    name: "libdrm_vivante_sources",
+    srcs: [
+        "vivante_bo.c",
+    ],
+}
diff --git a/vivante/libdrm_vivante.pc.in b/vivante/libdrm_vivante.pc.in
new file mode 100644
index 00000000..2598d6b3
--- /dev/null
+++ b/vivante/libdrm_vivante.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libdrm_vivante
+Description: Userspace interface to Vivante kernel DRM services
+Version: @PACKAGE_VERSION@
+Libs: -L${libdir} -ldrm_vivante
+Cflags: -I${includedir} -I${includedir}/libdrm
+Requires.private: libdrm
diff --git a/vivante/meson.build b/vivante/meson.build
new file mode 100644
index 00000000..4224c930
--- /dev/null
+++ b/vivante/meson.build
@@ -0,0 +1,56 @@
+# Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+libdrm_vivante = library(
+  'drm_vivante',
+  [files('vivante_bo.c'), config_file],
+  include_directories : [inc_root, inc_drm],
+  link_with : libdrm,
+  dependencies : [dep_pthread_stubs, dep_atomic_ops],
+  c_args : libdrm_c_args,
+  version : '0.0.0',
+  install : true,
+)
+
+ext_libdrm_tegra = declare_dependency(
+  link_with : [libdrm, libdrm_vivante],
+  include_directories : [inc_drm, include_directories('.')],
+)
+
+install_headers('vivante_bo.h', subdir : 'libdrm')
+
+pkg.generate(
+  name : 'libdrm_vivante',
+  libraries : libdrm_vivante,
+  subdirs : ['.', 'libdrm'],
+  version : meson.project_version(),
+  requires_private : 'libdrm',
+  description : 'Userspace interface to Vivante kernel DRM services',
+)
+
+test(
+  'vivante-symbols-check',
+  symbols_check,
+  args : [
+    '--lib', libdrm_vivante,
+    '--symbols-file', files('vivante-symbols.txt'),
+    '--nm', prog_nm.path(),
+  ],
+)
diff --git a/vivante/vivante-symbols.txt b/vivante/vivante-symbols.txt
new file mode 100644
index 00000000..a565f901
--- /dev/null
+++ b/vivante/vivante-symbols.txt
@@ -0,0 +1,23 @@
+__bss_end__
+__bss_start__
+__bss_start
+__end__
+_bss_end__
+_edata
+_end
+_fini
+_init
+drm_vivante_bo_create
+drm_vivante_bo_create_with_ts
+drm_vivante_bo_export_to_fd
+drm_vivante_bo_import_from_fd
+drm_vivante_bo_destroy
+drm_vivante_bo_get_handle
+drm_vivante_bo_mmap
+drm_vivante_bo_munmap
+drm_vivante_bo_query
+drm_vivante_bo_set_tiling
+drm_vivante_bo_get_tiling
+drm_vivante_bo_inc_timestamp
+drm_vivante_bo_get_timestamp
+drm_vivante_bo_ref_node
diff --git a/vivante/vivante_bo.c b/vivante/vivante_bo.c
new file mode 100644
index 00000000..bfa03ac2
--- /dev/null
+++ b/vivante/vivante_bo.c
@@ -0,0 +1,586 @@
+/****************************************************************************
+*
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
+*
+*    The material in this file is confidential and contains trade secrets
+*    of Vivante Corporation. This is proprietary information owned by
+*    Vivante Corporation. No part of this work may be disclosed,
+*    reproduced, copied, transmitted, or used in any way for any purpose,
+*    without the express written permission of Vivante Corporation.
+*
+*****************************************************************************/
+
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#define LOG_TAG "libdrm_vivante"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <log/log.h>
+
+#include <sys/mman.h>
+
+#include <xf86drm.h>
+
+#include <vivante_drm.h>
+
+#include "vivante_bo.h"
+
+struct drm_vivante
+{
+    /* driver fd. */
+    int fd;
+
+    struct drm_vivante_bo *bo_list;
+    pthread_mutex_t mutex;
+};
+
+struct drm_vivante_bo
+{
+    struct drm_vivante *drm;
+
+    uint32_t handle;
+
+    /* export prime fd if any */
+    int fd;
+    int tsFd;
+
+    uint32_t flags;
+    uint32_t size;
+
+    void *vaddr;
+
+    int refcount;
+    struct drm_vivante_bo *next;
+};
+
+
+int drm_vivante_create(int fd, struct drm_vivante **drmp)
+{
+    int supported = 0;
+    drmVersionPtr version;
+    struct drm_vivante *drm;
+
+    version = drmGetVersion(fd);
+    if (!version)
+        return -ENOMEM;
+
+    if (!strncmp(version->name, "vivante", version->name_len))
+        supported = 1;
+
+    drmFreeVersion(version);
+
+    if (!supported)
+        return -ENOTSUP;
+
+    drm = calloc(1, sizeof(struct drm_vivante));
+    if (!drm)
+        return -ENOMEM;
+
+    drm->fd = fd;
+    drm->bo_list = NULL;
+    pthread_mutex_init(&drm->mutex, NULL);
+
+    *drmp = drm;
+    return 0;
+}
+
+void drm_vivante_close(struct drm_vivante *drm)
+{
+    free(drm);
+}
+
+static inline void drm_vivante_bo_add_locked(struct drm_vivante *drm,
+                    struct drm_vivante_bo *bo)
+{
+    bo->refcount = 1;
+    bo->next = drm->bo_list;
+    drm->bo_list = bo;
+}
+
+static void drm_vivante_bo_add(struct drm_vivante *drm,
+                    struct drm_vivante_bo *bo)
+{
+    pthread_mutex_lock(&drm->mutex);
+    drm_vivante_bo_add_locked(drm, bo);
+    pthread_mutex_unlock(&drm->mutex);
+}
+
+static struct drm_vivante_bo *drm_vivante_bo_lookup(
+                    struct drm_vivante *drm, uint32_t handle)
+{
+    struct drm_vivante_bo *bo;
+
+    for (bo = drm->bo_list; bo != NULL; bo = bo->next) {
+        if (bo->handle == handle)
+            break;
+    }
+    if (bo)
+        bo->refcount++;
+    return bo;
+}
+
+/* returns refcount. */
+static int drm_vivante_bo_decref(struct drm_vivante *drm,
+                struct drm_vivante_bo *bo)
+{
+    int ret;
+
+    pthread_mutex_lock(&drm->mutex);
+    ret = --bo->refcount;
+
+    if (ret > 0)
+        goto out;
+
+    /* unlink bo. */
+    if (bo == drm->bo_list)
+        drm->bo_list = bo->next;
+    else {
+        struct drm_vivante_bo *prev = NULL;
+        for (prev = drm->bo_list; prev != NULL; prev = prev->next) {
+            if (prev->next == bo) {
+                prev->next = bo->next;
+                break;
+            }
+        }
+    }
+
+out:
+    pthread_mutex_unlock(&drm->mutex);
+    return ret;
+}
+
+static int drm_vivante_bo_init(struct drm_vivante *drm,
+                struct drm_vivante_bo **bop)
+{
+    struct drm_vivante_bo *bo;
+
+    bo = calloc(1, sizeof(*bo));
+    if (!bo)
+        return -ENOMEM;
+
+    bo->drm = drm;
+    bo->fd = -1;
+    bo->tsFd = -1;
+    bo->vaddr = NULL;
+
+    *bop = bo;
+    return 0;
+}
+
+int drm_vivante_bo_create(struct drm_vivante *drm,
+            uint32_t flags, uint32_t size, struct drm_vivante_bo **bop)
+{
+    int err = 0;
+    struct drm_vivante_bo *bo;
+    struct drm_viv_gem_create args = {
+        .flags = flags,
+        .size  = size
+    };
+
+    if (size == 0)
+        return -EINVAL;
+
+    if (!drm || !bop)
+        return -EINVAL;
+
+    err = drm_vivante_bo_init(drm, &bo);
+    if (err) {
+        return err;
+    }
+
+    if (drmIoctl(drm->fd, DRM_IOCTL_VIV_GEM_CREATE, &args)) {
+        free(bo);
+        return -errno;
+    }
+    bo->handle = args.handle;
+    bo->flags = flags;
+    bo->size = size;
+    bo->tsFd = -1;
+
+    drm_vivante_bo_add(drm, bo);
+    *bop = bo;
+    return 0;
+}
+
+int drm_vivante_bo_create_with_ts(struct drm_vivante *drm,
+            uint32_t flags, uint32_t size, struct drm_vivante_bo **bop)
+{
+    int err = 0;
+    uint32_t ts_handle = 0;
+    struct drm_vivante_bo *bo;
+    struct drm_viv_gem_create args = {
+        .flags = flags,
+        .size  = size
+    };
+    struct drm_gem_close close_args;
+    struct drm_viv_gem_attach_aux aux_args;
+    const uint32_t valid_ts_flags = DRM_VIV_GEM_CONTIGUOUS | DRM_VIV_GEM_SECURE;
+
+    if (size == 0)
+        return -EINVAL;
+
+    if (!drm || !bop)
+        return -EINVAL;
+
+    err = drm_vivante_bo_init(drm, &bo);
+    if (err)
+        return err;
+
+    if (drmIoctl(drm->fd, DRM_IOCTL_VIV_GEM_CREATE, &args)) {
+        err = -errno;
+        goto err_close;
+    }
+    bo->handle = args.handle;
+
+    /* alloc ts handle, size is master buffer size / 256, align up to 256B. And add the extra 256 byte for new HW FC feature. */
+    args.flags = flags & valid_ts_flags;
+    args.size  = (((size >> 8) + 0xff) & ~0xff) + 0xff;
+    if (drmIoctl(drm->fd, DRM_IOCTL_VIV_GEM_CREATE, &args)) {
+        err = -errno;
+        goto err_close;
+    }
+    ts_handle = args.handle;
+
+    /* ref ts_handle in master handle. */
+    aux_args.handle = bo->handle;
+    aux_args.ts_handle = ts_handle;
+    if (drmIoctl(drm->fd, DRM_IOCTL_VIV_GEM_ATTACH_AUX, &aux_args)) {
+        err = -errno;
+        goto err_close;
+    }
+
+    /* Now ts was attached to master, destroy it now. */
+    close_args.handle = ts_handle;
+    if (drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &close_args)) {
+        err = -errno;
+        goto err_close;
+    }
+    ts_handle = 0;
+
+    bo->flags = flags;
+    bo->size = size;
+
+    drm_vivante_bo_add(drm, bo);
+    *bop = bo;
+    return 0;
+
+err_close:
+    if (bo->handle) {
+
+        if (ts_handle) {
+            close_args.handle = ts_handle;
+            drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &close_args);
+        }
+
+        close_args.handle = bo->handle;
+        drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &close_args);
+    }
+
+    free(bo);
+    return err;
+}
+
+int drm_vivante_bo_export_to_fd(struct drm_vivante_bo *bo, int *pfd)
+{
+    if (!bo || !pfd)
+        return -EINVAL;
+
+    if (bo->fd < 0) {
+        int fd;
+        if (drmPrimeHandleToFD(bo->drm->fd, bo->handle, O_RDWR, &fd))
+            return -errno;
+        bo->fd = fd;
+    }
+
+    *pfd = bo->fd;
+    return 0;
+}
+
+int drm_vivante_bo_import_from_fd(struct drm_vivante *drm, int fd,
+            struct drm_vivante_bo **bop)
+{
+    int err;
+    uint64_t size;
+    uint32_t handle = 0;
+    struct drm_vivante_bo *bo = NULL;
+
+    if (!drm || !bop || fd < 0)
+        return -EINVAL;
+
+    pthread_mutex_lock(&drm->mutex);
+
+    // ALOGE("drm_vivante_bo_import_from_fd called with drm->fd=%d and fd=%d", drm->fd, fd);
+
+    if (drmPrimeFDToHandle(drm->fd, fd, &handle)) {
+        err = -errno;
+        ALOGE("drm_vivante_bo_import_from_fd drmPrimeFDToHandle err=%d", err);
+        goto err_close;
+    }
+
+    bo = drm_vivante_bo_lookup(drm, handle);
+    if (bo) {
+        pthread_mutex_unlock(&drm->mutex);
+        *bop = bo;
+        return 0;
+    }
+
+    err = drm_vivante_bo_init(drm, &bo);
+    if (err)
+        goto err_close;
+    bo->handle = handle;
+
+    err = drm_vivante_bo_query(bo, DRM_VIV_GEM_PARAM_SIZE, &size);
+    if (err) {
+        ALOGE("drm_vivante_bo_import_from_fd drm_vivante_bo_query err=%d", err);
+        goto err_close;
+    }
+    bo->size = (uint32_t)size;
+
+    drm_vivante_bo_add_locked(drm, bo);
+    pthread_mutex_unlock(&drm->mutex);
+
+    *bop = bo;
+    return 0;
+
+err_close:
+    pthread_mutex_unlock(&drm->mutex);
+
+    if (handle > 0) {
+        struct drm_gem_close close_args = {
+            .handle = handle,
+        };
+        drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &close_args);
+    }
+    free(bo);
+
+    return err;
+}
+
+void drm_vivante_bo_destroy(struct drm_vivante_bo *bo)
+{
+    struct drm_gem_close close_args;
+
+    if (!bo)
+        return;
+
+    if (drm_vivante_bo_decref(bo->drm, bo) != 0)
+        return;
+
+    if (bo->vaddr) {
+        drm_vivante_bo_munmap(bo);
+    }
+
+    if(bo->tsFd >=0) {
+        close(bo->tsFd);
+        bo->tsFd = -1;
+    }
+    close_args.handle = bo->handle;
+    drmIoctl(bo->drm->fd, DRM_IOCTL_GEM_CLOSE, &close_args);
+
+    free(bo);
+}
+
+int drm_vivante_bo_get_handle(struct drm_vivante_bo *bo, uint32_t *handle)
+{
+    if (!bo || !handle)
+        return -EINVAL;
+
+    *handle = bo->handle;
+    return 0;
+}
+
+int drm_vivante_bo_get_ts_fd(struct drm_vivante_bo *bo, int *value)
+{
+    if (!bo)
+        return -EINVAL;
+
+    *value = bo->tsFd;
+    return 0;
+}
+
+int drm_vivante_bo_set_ts_fd(struct drm_vivante_bo *bo, int value)
+{
+    if (!bo)
+        return -EINVAL;
+
+    bo->tsFd = value;
+    return 0;
+}
+
+
+static int clean_bo_cache(struct drm_vivante_bo *bo)
+{
+    struct drm_viv_gem_cache args = {
+        .op = DRM_VIV_GEM_CLEAN_CACHE,
+        .handle = bo->handle,
+        .logical = (uint64_t)(uintptr_t)bo->vaddr,
+        .bytes = bo->size
+    };
+
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_CACHE, &args))
+        return -errno;
+
+    return 0;
+}
+
+int drm_vivante_bo_mmap(struct drm_vivante_bo *bo, void **vaddr)
+{
+    struct drm_viv_gem_lock args;
+
+    if (!bo || !vaddr)
+        return -EINVAL;
+
+    /* already locked */
+    if (bo->vaddr) {
+        *vaddr = bo->vaddr;
+        return 0;
+    }
+
+    args.handle = bo->handle;
+    args.cacheable = (bo->flags & DRM_VIV_GEM_CACHED) ? 1 : 0;
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_LOCK, &args))
+        return -errno;
+
+    bo->vaddr = (void *)(uintptr_t)args.logical;
+
+    *vaddr = bo->vaddr;
+    return 0;
+}
+
+int drm_vivante_bo_munmap(struct drm_vivante_bo *bo)
+{
+    struct drm_viv_gem_unlock args;
+
+    if (!bo || !bo->vaddr)
+        return -EINVAL;
+
+    args.handle = bo->handle;
+    if (bo->flags & DRM_VIV_GEM_CACHED) {
+        int err = clean_bo_cache(bo);
+        if (err)
+            return err;
+    }
+
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_UNLOCK, &args))
+        return -errno;
+
+    bo->vaddr = NULL;
+    return 0;
+}
+
+int drm_vivante_bo_query(struct drm_vivante_bo *bo,
+            uint32_t param, uint64_t *value)
+{
+    struct drm_viv_gem_query args = {
+        .param = param,
+    };
+
+    if (!bo || !value)
+        return -EINVAL;
+
+    // ALOGE("drm_vivante_bo_query called with bo->drm->fd=%d", bo->drm->fd);
+
+    args.handle = bo->handle;
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_QUERY, &args))
+        return -errno;
+
+    *value = args.value;
+    return 0;
+}
+
+int drm_vivante_bo_set_tiling(struct drm_vivante_bo *bo,
+            const struct drm_vivante_bo_tiling *tiling)
+{
+    struct drm_viv_gem_set_tiling args;
+
+    if (!bo || !tiling)
+        return -EINVAL;
+
+    args = (struct drm_viv_gem_set_tiling) {
+        .handle = bo->handle,
+        .tiling_mode = tiling->tiling_mode,
+        .ts_mode = tiling->ts_mode,
+        .ts_cache_mode = tiling->ts_cache_mode,
+        .clear_value = tiling->clear_value,
+    };
+
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_SET_TILING, &args))
+        return -errno;
+
+    return 0;
+}
+
+int drm_vivante_bo_get_tiling(struct drm_vivante_bo *bo,
+            struct drm_vivante_bo_tiling *tiling)
+{
+    struct drm_viv_gem_get_tiling args;
+
+    if (!bo || !tiling)
+        return -EINVAL;
+
+    args.handle = bo->handle;
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_GET_TILING, &args))
+        return -errno;
+
+    tiling->tiling_mode = args.tiling_mode;
+    tiling->ts_mode = args.ts_mode;
+    tiling->ts_cache_mode = args.ts_cache_mode;
+    tiling->clear_value = args.clear_value;
+
+    return 0;
+}
+
+static inline int inc_bo_timestamp(struct drm_vivante_bo *bo,
+                        uint32_t inc, uint64_t *timestamp)
+{
+    struct drm_viv_gem_timestamp args = {
+        .handle = bo->handle,
+        .inc = inc,
+    };
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_TIMESTAMP, &args))
+        return -errno;
+
+    if (timestamp)
+        *timestamp = args.timestamp;
+    return 0;
+}
+
+int drm_vivante_bo_inc_timestamp(struct drm_vivante_bo *bo,
+            uint64_t *timestamp)
+{
+    if (!bo)
+        return -EINVAL;
+    return inc_bo_timestamp(bo, 1, timestamp);
+}
+
+int drm_vivante_bo_get_timestamp(struct drm_vivante_bo *bo,
+            uint64_t *timestamp)
+{
+    if (!bo || !timestamp)
+        return -EINVAL;
+    return inc_bo_timestamp(bo, 0, timestamp);
+}
+
+int drm_vivante_bo_ref_node(struct drm_vivante_bo *bo,
+            uint32_t *node, uint32_t *ts_node)
+{
+    struct drm_viv_gem_ref_node args;
+
+    if (!bo || !node || !ts_node)
+        return -EINVAL;
+
+    args.handle = bo->handle;
+    if (drmIoctl(bo->drm->fd, DRM_IOCTL_VIV_GEM_REF_NODE, &args))
+        return -errno;
+
+    *node = args.node;
+    *ts_node = args.ts_node;
+    return 0;
+}
diff --git a/vivante/vivante_bo.h b/vivante/vivante_bo.h
new file mode 100644
index 00000000..e739df64
--- /dev/null
+++ b/vivante/vivante_bo.h
@@ -0,0 +1,84 @@
+/****************************************************************************
+*
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
+*
+*    The material in this file is confidential and contains trade secrets
+*    of Vivante Corporation. This is proprietary information owned by
+*    Vivante Corporation. No part of this work may be disclosed,
+*    reproduced, copied, transmitted, or used in any way for any purpose,
+*    without the express written permission of Vivante Corporation.
+*
+*****************************************************************************/
+
+
+#ifndef __DRM_VIVANTE_H__
+#define __DRM_VIVANTE_H__
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <vivante_drm.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+struct drm_vivante_bo;
+struct drm_vivante;
+
+struct drm_vivante_bo_tiling {
+    uint32_t tiling_mode;
+    uint32_t ts_mode;
+    uint32_t ts_cache_mode;
+    uint64_t clear_value;
+};
+
+/* caller owns the driver fd. */
+int drm_vivante_create(int fd, struct drm_vivante **drmp);
+void drm_vivante_close(struct drm_vivante *drm);
+
+int drm_vivante_bo_create(struct drm_vivante *drm,
+            uint32_t flags, uint32_t size, struct drm_vivante_bo **bop);
+
+/* create bo with auxillary tile-status bo. */
+int drm_vivante_bo_create_with_ts(struct drm_vivante *drm,
+            uint32_t flags, uint32_t size, struct drm_vivante_bo **bop);
+
+/* caller owns the fd. */
+int drm_vivante_bo_export_to_fd(struct drm_vivante_bo *bo, int *pfd);
+/* caller still owns the fd upon return. */
+int drm_vivante_bo_import_from_fd(struct drm_vivante *drm, int fd,
+        struct drm_vivante_bo **bop);
+
+void drm_vivante_bo_destroy(struct drm_vivante_bo *bo);
+
+/* do not close the handle directly. */
+int drm_vivante_bo_get_handle(struct drm_vivante_bo *bo, uint32_t *handle);
+int drm_vivante_bo_get_ts_fd(struct drm_vivante_bo *bo, int *value);
+int drm_vivante_bo_set_ts_fd(struct drm_vivante_bo *bo, int value);
+
+
+int drm_vivante_bo_mmap(struct drm_vivante_bo *bo, void **vaddr);
+int drm_vivante_bo_munmap(struct drm_vivante_bo *bo);
+
+int drm_vivante_bo_query(struct drm_vivante_bo *bo,
+            uint32_t param, uint64_t *value);
+
+int drm_vivante_bo_set_tiling(struct drm_vivante_bo *bo,
+            const struct drm_vivante_bo_tiling *tiling);
+int drm_vivante_bo_get_tiling(struct drm_vivante_bo *bo,
+            struct drm_vivante_bo_tiling *tiling);
+
+/* output inc'ed timestamp, optional. */
+int drm_vivante_bo_inc_timestamp(struct drm_vivante_bo *bo,
+            uint64_t *timestamp);
+int drm_vivante_bo_get_timestamp(struct drm_vivante_bo *bo,
+            uint64_t *timestamp);
+
+int drm_vivante_bo_ref_node(struct drm_vivante_bo *bo,
+            uint32_t *node, uint32_t *ts_node);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* __DRM_VIVANTE_H__ */
-- 
2.17.1

